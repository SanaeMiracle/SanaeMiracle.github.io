<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Fang">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Fang">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Fangck">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Fang</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Fang</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/17/vue/Vue%E6%8C%87%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fangck">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/17/vue/Vue%E6%8C%87%E4%BB%A4/" class="post-title-link" itemprop="url">Vue 基本指令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-17 23:23:42" itemprop="dateCreated datePublished" datetime="2022-09-17T23:23:42+08:00">2022-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-18 00:43:23" itemprop="dateModified" datetime="2022-09-18T00:43:23+08:00">2022-09-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Vue-基本指令"><a href="#Vue-基本指令" class="headerlink" title="Vue 基本指令"></a>Vue 基本指令</h1><h2 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h2><p><code>v-text</code>，该指令的用法同原生 JS 中的 <code>innerText</code>，更新绑定元素内部的文本内容</p>
<pre><code>    &lt;div id=&quot;div&quot;&gt;
        &lt;span v-text=&quot;msg&quot;&gt;&lt;/span&gt;
        &lt;!--不会有闪烁问题--&gt;&lt;!-- 和下面的一样 --&gt;
        &lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt;
    &lt;/div&gt;
</code></pre>
<p>与插值语法的区别：<code>v-text</code>会替换掉节点中的内容，<code>&#123;&#123;xx&#125;&#125;</code>则不会。</p>
<h2 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h2><p><code>v-html</code>，该指令用法同原生 JS 的 <code>innerHTML</code>，可以解析内部的 HTML 标签</p>
<h2 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h2><p><code>v-cloak</code>，该指令 CSS 一起使用，用于隐藏还没有开始编译的<code>&#123;&#123;&#125;&#125;`(插值表达式)直到编译完成，解决其闪烁问题
使用`css`配合`v-cloak`可以解决网速慢时页面展示出`&#123;&#123;xxx&#125;&#125;</code>的问题。</p>
<p>本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉<code>v-cloak</code>属性。</p>
<h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h2><p><code>v-show</code>，该指令用于显示和隐藏 DOM 元素，<strong>根据表达式之真假值</strong>，切换元素的 <code>display</code> 属性值</p>
<ul>
<li><code>v-show</code> 值为<code>true</code>时显示</li>
<li>当条件变化时该指令触发过渡效果，切换频率较高的场景</li>
<li>不展示的DOM元素未被移除，仅仅是使用样式隐藏掉</li>
<li><code>v-show</code> 指令不支持在<code>&lt;template&gt;&lt; /template&gt;</code>标签上写，也不支持 <code>v-else</code>，一般来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好，如果在运行时条件很少改变，则使用 <code>v-if</code> 较好</li>
</ul>
<h2 id="v-if，v-else-与-v-else-if"><a href="#v-if，v-else-与-v-else-if" class="headerlink" title="v-if，v-else 与 v-else-if"></a>v-if，v-else 与 v-else-if</h2><p><code>v-if</code>，该指令用于是否渲染 DOM 元素，传入一个布尔值，通过该布尔值的条件改变实现对于 DOM 元素的删除和重建，该指令不同于 <code>v-show</code>，而是会完全销毁这个 DOM 元素<br>**注意:**当条件变化时该指令触发过渡效果</p>
<p><code>v-else</code>， 该指令用于 不需要任何表达式 ，但是在该指令的前一个兄弟元素必须有 <code>v-if</code> 或者 <code>v-else-if</code> 指令，该指令的用处是为 <code>v-if</code> 或者 <code>v-else-if</code> 添加 <code>else</code> 的选项</p>
<pre><code>    &lt;div v-if=&quot;Math.random() &gt; 0.5&quot;&gt;Now you see me&lt;/div&gt;
    &lt;div v-else&gt;Now you don&#39;t&lt;/div&gt;
</code></pre>
<p><code>v-else-if</code>，该指令用于用于 <code>v-if</code> 的 <code>else if</code> 选项，前一个兄弟元素必须要 <code>v-if</code> 指令，并且该指令可以链式调用，也就是说可以调用多次 <code>v-else-if</code> 指令</p>
<pre><code>    &lt;div v-if=&quot;type === &#39;A&#39;&quot;&gt;A&lt;/div&gt;
    &lt;div v-else-if=&quot;type === &#39;B&#39;&quot;&gt;B&lt;/div&gt;
    &lt;div v-else-if=&quot;type === &#39;C&#39;&quot;&gt;C&lt;/div&gt;
    &lt;div v-else&gt;Not A/B/C&lt;/div&gt;
</code></pre>
<h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><p><code>v-for</code>该指令可以基于源数据多次渲染元素或模板块，用于循环遍历某个数组或对象，如果只用一个变量代表得到是数组或对象的 <code>value</code> 值</p>
<p>**注意:在内部必须使用固定的 <code>item in/of items</code>**形式的特殊语法(下面的 <code>in</code> 都可以用 <code>of</code> 代替，并且更符合实际)</p>
<pre><code>    &lt;ul id=&quot;example-1&quot;&gt;
        &lt;li v-for=&quot;item in items&quot;&gt;
            &#123;&#123; item.message &#125;&#125;
            &lt;!--Foo Bar--&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
        var example1 = new Vue(&#123;
            el: &#39;#example-1&#39;，
            data: &#123;
                items: [&#123; message: &#39;Foo&#39; &#125;， &#123; message: &#39;Bar&#39; &#125;]，
            &#125;，
        &#125;)
    &lt;/script&gt;
</code></pre>
<p><strong>遍历数组</strong>时其实还支持第二个变量，代表的是遍历数组的索引值</p>
<pre><code>    &lt;ul id=&quot;example-2&quot;&gt;
        &lt;li v-for=&quot;(item， index) in items&quot;&gt;
            &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;
            &lt;!--
              Parent-0-Foo
              Parent-1-Bar
          --&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
    &lt;script&gt;
        var example2 = new Vue(&#123;
            el: &#39;#example-2&#39;，
            data: &#123;
                parentMessage: &#39;Parent&#39;，
                items: [&#123; message: &#39;Foo&#39; &#125;， &#123; message: &#39;Bar&#39; &#125;]，
            &#125;，
        &#125;)
    &lt;/script&gt;
</code></pre>
<ul>
<li><p><code>遍历对象</code>时还可以接受第二三两个变量，分别代表了键名和索引值</p>
<pre><code>  &lt;ul id=&quot;v-for-object&quot; class=&quot;demo&quot;&gt;
      &lt;div v-for=&quot;(value， key， index) in object&quot;&gt;
          &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;
          &lt;!--
         0. firstName: John
         1. lastName: Doe
         2. age: 30
        --&gt;
      &lt;/div&gt;
  &lt;/ul&gt;
  &lt;script&gt;
      new Vue(&#123;
          el: &#39;#v-for-object&#39;，
          data: &#123;
              object: &#123;
                  firstName: &#39;John&#39;，
                  lastName: &#39;Doe&#39;，
                  age: 30，
              &#125;，
          &#125;，
      &#125;)
  &lt;/script&gt;
</code></pre>
</li>
</ul>
<p>**注意:**当 <code>v-for</code> 和 <code>v-if</code> 处于同一节点时，<code>v-for</code> 的优先级比 <code>v-if</code> 更高，这意味着 <code>v-if</code> 将分别重复运行于每个 <code>v-for</code> 循环中，当想为仅有的一些项渲染节点时，这种优先级的机制会十分有用</p>
<pre><code>    &lt;li v-for=&quot;todo in todos&quot; v-if=&quot;!todo.isComplete&quot;&gt;&#123;&#123; todo &#125;&#125;&lt;/li&gt;
    &lt;!--
        官方并不建议v-for和v-if指令一起使用，如果要使用这种方式，就进行条件渲染
    --&gt;

    &lt;!--
        如果想有条件才继续v-for指令，则可以将v-if置于外层元素(或&lt;template&gt;)上
    --&gt;
    &lt;ul v-if=&quot;todos.length&quot;&gt;
        &lt;li v-for=&quot;todo in todos&quot;&gt;&#123;&#123; todo &#125;&#125;&lt;/li&gt;
    &lt;/ul&gt;
    &lt;p v-else&gt;No todos left!&lt;/p&gt;
    &lt;!--
        条件渲染
        v-if如果想只写一个而同时切换多个元素，可以在最外成包裹一层&lt;template&gt;&lt;/template&gt;，
        在这个标签上面使用v-if，在渲染的时候并不会将&lt;template&gt;标签渲染出来
    --&gt;
</code></pre>
<h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h2><p><code>v-bind</code>，该指令用于动态绑定一个或多个特性，该方法绑定的特性与普通的属性效果一致，只是其内部会被解析为 JS 表达式，而不是普通特性一样会是一个字符串<br><strong>修辞符</strong></p>
<ul>
<li><code>.prop</code>  被用于绑定 DOM 属性(<code>property</code>)</li>
<li><code>.camel</code>  将短横线命名法特性名转换为驼峰命名法</li>
<li><code>.sync</code>  会扩展成一个更新父组件绑定值的 <code>v-on</code> 侦听器</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li><p>该指令有其简写写法，通过冒号<code>:</code>来代替 <code>v-bind</code>:</p>
</li>
<li><p>该指令可以动态对绑定的参数进行改变，参数用<code>[]</code>括起来</p>
<pre><code>  &lt;!-- 绑定一个属性 --&gt;
  &lt;img v-bind:src=&quot;imageSrc&quot;&gt;
  
  &lt;!-- 动态特性名 (2.6.0+) --&gt;
  &lt;button v-bind:[key]=&quot;value&quot;&gt;&lt;/button&gt;
  
  &lt;!-- 缩写 --&gt;
  &lt;img :src=&quot;imageSrc&quot;&gt;
  
  &lt;!-- 动态特性名缩写 (2.6.0+) --&gt;
  &lt;button :[key]=&quot;value&quot;&gt;&lt;/button&gt;
  
  &lt;!-- 内联字符串拼接 --&gt;
  &lt;img :src=&quot;&#39;/path/to/images/&#39; + fileName&quot;&gt;
  
  &lt;!-- class 绑定 --&gt;
  &lt;div :class=&quot;&#123; red: isRed &#125;&quot;&gt;&lt;/div&gt;&lt;!--对象通过布尔值确定是否传入class中--&gt;
  &lt;div :class=&quot;[classA， classB]&quot;&gt;&lt;/div&gt;&lt;!--数组会直接将类名传入到class中--&gt;
  &lt;div :class=&quot;[classA， &#123; classB: isB， classC: isC &#125;]&quot;&gt;&lt;!--对象和数组可以混用--&gt;
  
  &lt;!-- style 绑定 --&gt;
  &lt;div :style=&quot;&#123; fontSize: size + &#39;px&#39; &#125;&quot;&gt;&lt;/div&gt;&lt;!--通过对象写入每个属性--&gt;
  &lt;div :style=&quot;[styleObjectA， styleObjectB]&quot;&gt;&lt;/div&gt;&lt;!--数组的成员中实际是一个个对象--&gt;
  
  &lt;!-- 绑定一个有属性的对象 --&gt;
  &lt;div v-bind=&quot;&#123; id: someProp， &#39;other-attr&#39;: otherProp &#125;&quot;&gt;&lt;/div&gt;
  
  &lt;!-- 通过 prop 修饰符绑定 DOM 属性 --&gt;
  &lt;div v-bind:text-content.prop=&quot;text&quot;&gt;&lt;/div&gt;
  
  &lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&gt;
  &lt;my-component :prop=&quot;someThing&quot;&gt;&lt;/my-component&gt;
  
  &lt;!-- 通过 $props 将父组件的 props 一起传给子组件 --&gt;
  &lt;child-component v-bind=&quot;$props&quot;&gt;&lt;/child-component&gt;
  
  &lt;!-- XLink --&gt;
  &lt;svg&gt;&lt;a :xlink:special=&quot;foo&quot;&gt;&lt;/a&gt;&lt;/svg&gt;
</code></pre>
</li>
</ul>
<h2 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h2><p><code>v-on</code>，该指令用于绑定监听事件，表达式可以是一个方法的名字或一个内联语句(也就是说在传入事件的时候可以选择加()可以选择不加()，推荐在传入参数的时候添加，在不传参的时候写事件名)</p>
<p>**参数:**该指令的参数为原生 JS 中的事件名，只不过没有 <code>on</code></p>
<p><strong>修饰符</strong></p>
<ul>
<li><p><code>.stop</code>  调用 <code>event.stopPropagation()</code>，会阻止本元素上的事件进行冒泡传播 </p>
</li>
<li><p><code>.prevent</code>  调用 <code>event.preventDefault()</code>，不能和<code>.passive</code> 一起使用 </p>
</li>
</ul>
<ul>
<li><code>.capture</code>  添加事件侦听器时使用 <code>capture</code> 模式，父元素会执行在子元素上进行的同名事件 </li>
</ul>
<ul>
<li><code>.self</code>  只当事件是从侦听器绑定的元素本身触发时才触发回调，只会真正自己触发的事件才会进行，和<code>.stop</code> 是有区别的，这个只会阻止自己的冒泡，但不会阻止该元素的父元素事件的冒泡进行 </li>
</ul>
<ul>
<li><code>.&#123;keyCode | keyAlias&#125;</code>  只当事件是从特定键触发时才触发回调，可以是表示键盘字符的数字或者表示特效事件的按键修饰符 </li>
</ul>
<ul>
<li><code>.native</code>  监听组件根元素的原生事件，一个 Vue 实例内部通过只能 v-on 只能绑定自己内部的方法，不能绑定原生 DOM 事件的方法，通过该修饰符就可以使用原生 JS 的事件方法了 </li>
</ul>
<ul>
<li><code>.once</code>  只触发一次回调 </li>
</ul>
<ul>
<li><code>.left</code>  只当点击鼠标左键时触发 </li>
</ul>
<ul>
<li><code>.right</code>  只当点击鼠标右键时触发 </li>
</ul>
<ul>
<li><code>.middle</code>  只当点击鼠标中键时触发 </li>
</ul>
<ul>
<li><code>.passive</code>  不用查找是否阻止默认事件的请求直接进行操作。<br>  如在滚动页面时的 <code>onscroll</code> 事件，每次触发事件时浏览器都会查看是否有阻止默认滚动事件的操作，但是如果本来就没有进行这个操作，在滚动的时候就会出现卡的的情况，因为在触发滚动条滚动时总会先查找请求，这个修饰符就是告诉浏览器不用进行查找直接进行滚动操作。因为作用的冲突，所以不能和<code>.prevent</code> 一起使用</li>
</ul>
<p><strong>注意:</strong></p>
<ul>
<li><p>该指令有简写形式，通过<code>@</code>来代替 <code>v-on</code>:</p>
</li>
<li><p>该指令可以动态对绑定的参数进行改变，参数用中括号<code>[]</code>括起来</p>
</li>
</ul>
<pre><code>    &lt;!-- 方法处理器 --&gt;
    &lt;button v-on:click=&quot;doThis&quot;&gt;&lt;/button&gt;
    
    &lt;!-- 动态事件 (2.6.0+) --&gt;
    &lt;button v-on:[event]=&quot;doThis&quot;&gt;&lt;/button&gt;
    
    &lt;!-- 内联语句 --&gt;
    &lt;button v-on:click=&quot;doThat(&#39;hello&#39;， $event)&quot;&gt;&lt;/button&gt;
    
    &lt;!-- 缩写 --&gt;
    &lt;button @click=&quot;doThis&quot;&gt;&lt;/button&gt;
    
    &lt;!-- 动态事件缩写 (2.6.0+) --&gt;
    &lt;button @[event]=&quot;doThis&quot;&gt;&lt;/button&gt;
    
    &lt;!-- 停止冒泡 --&gt;
    &lt;button @click.stop=&quot;doThis&quot;&gt;&lt;/button&gt;
    
    &lt;!-- 阻止默认行为 --&gt;
    &lt;button @click.prevent=&quot;doThis&quot;&gt;&lt;/button&gt;
    
    &lt;!-- 阻止默认行为，没有表达式 --&gt;
    &lt;form @submit.prevent&gt;&lt;/form&gt;
    
    &lt;!--  串联修饰符 --&gt;
    &lt;button @click.stop.prevent=&quot;doThis&quot;&gt;&lt;/button&gt;
    
    &lt;!-- 键修饰符，键别名 --&gt;
    &lt;input @keyup.enter=&quot;onEnter&quot;&gt;
    
    &lt;!-- 键修饰符，键代码 --&gt;
    &lt;input @keyup.13=&quot;onEnter&quot;&gt;
    
    &lt;!-- 点击回调只会触发一次 --&gt;
    &lt;button v-on:click.once=&quot;doThis&quot;&gt;&lt;/button&gt;
    
    &lt;!-- 对象语法 (2.4.0+) --&gt;
    &lt;button v-on=&quot;&#123; mousedown: doThis， mouseup: doThat &#125;&quot;&gt;&lt;/button&gt;
    
    &lt;!-- 组件中的自定义事件 --&gt;
    &lt;my-component @my-event=&quot;handleThis&quot;&gt;&lt;/my-component&gt;
    
    &lt;!-- 内联语句 --&gt;
    &lt;my-component @my-event=&quot;handleThis(123， $event)&quot;&gt;&lt;/my-component&gt;
    
    &lt;!-- 组件中的原生事件 --&gt;
    &lt;my-component @click.native=&quot;onClick&quot;&gt;&lt;/my-component&gt;
</code></pre>
<h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><p><code>v-model</code>，该指令用于表单内的标签进行双向的数据绑定 </p>
<p>**注意:**v-model 只能绑定给 <code>input</code>，<code>textarea</code>，<code>select</code> 等表单元素和自定义的组件中，除此之外不能在其他标签上绑定<br><strong>与<code>v-bind</code>的区别</strong>：</p>
<ul>
<li><code>v-bind</code>是单向绑定，而<code>v-model</code>是双向绑定；</li>
<li><code>v-bind</code>只能将<code>vue</code>中的数据同步到页面，而<code>v-model</code>不只能将<code>vue</code>中的数据同步到页面，还可以将用户数据的数据赋值给<code>vue</code>中的属性</li>
</ul>
<p><strong>修辞符</strong>: </p>
<ul>
<li><code>.lazy</code>  取代 input 监听 change 事件，默认在用户写入值时是使用的 <code>input</code> 事件，也就是当值输入完成后才会触发事件，而 change 是一些有输入法的语言在值还没有输入时就时刻监听改变 </li>
<li><code>.number</code> 输入字符串转为有效的数字 </li>
<li><code>.trim</code>  输入首尾空格过滤 </li>
</ul>
<p><strong>用法</strong>: </p>
<ul>
<li><strong>如果是对 <code>input</code> 文本框和 <code>textarea</code> 绑定的</strong>，绑定的值会根据输入的内容，就是将内部的变量的值改为 value 中的值 </li>
</ul>
<ul>
<li><p>**如果是对复选框绑定的 **</p>
<ul>
<li><p><strong>如果绑定的变量不是数组</strong>，会根据复选框是否被选中而改变为 false 或 true，即使原来不是布尔值也会被强制转换为布尔值，这是因为双向的数据绑定，如果是有多个复选框，那么则会一起被选中或不选中 </p>
</li>
<li><p><strong>如果变量是数组</strong>，则会将 value 属性中的值(没有写 value 属性会传入 null)传入该数组作为其中的一个成员，Vue 会根据数组内部的值来判断是否选中该复选框(内部其实就是这样运作的)，如果 value 值一样会有多个复选框被选中，再次点击就会将该值删去然后取消复选框的选中</p>
</li>
</ul>
</li>
</ul>
<pre><code>    &lt;div id=&quot;example&quot;&gt;
        &lt;input
            type=&quot;checkbox&quot;
            id=&quot;jack&quot;
            value=&quot;Jack&quot;
            v-model=&quot;checkedNames&quot;
        /&gt;
        &lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt;
        &lt;input
            type=&quot;checkbox&quot;
            id=&quot;john&quot;
            value=&quot;John&quot;
            v-model=&quot;checkedNames&quot;
        /&gt;
        &lt;label for=&quot;john&quot;&gt;John&lt;/label&gt;
        &lt;input
            type=&quot;checkbox&quot;
            id=&quot;mike&quot;
            value=&quot;Mike&quot;
            v-model=&quot;checkedNames&quot;
        /&gt;
        &lt;label for=&quot;mike&quot;&gt;Mike&lt;/label&gt;
        &lt;br /&gt;
        &lt;span&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt;
    &lt;/div&gt;

    &lt;!--也可以在被选中和没被选择直接设置不同的值--&gt;
    &lt;input
        type=&quot;checkbox&quot;
        v-model=&quot;toggle&quot;
        true-value=&quot;yes&quot;
        false-value=&quot;no&quot;
    /&gt;
    &lt;!--
        当选中时 vm.toggle === &#39;yes&#39; 当没有选中时 vm.toggle === &#39;no&#39;
        注意:点击了才会改变值，如果没有点击过而变量本身有值的话就不会是fasle-value的值
    --&gt;
</code></pre>
<ul>
<li><p><strong>如果是对单选按钮进行绑定的</strong>，变量值会随着选中单选框的 <code>value</code> 值而变化，如果变量的值刚开始就是一个单选框的 <code>value</code> 值，那么就会自动选中这个单选框<br>  **注意: **</p>
<ul>
<li><p>单选框和复选框即使不写相同的 <code>name</code> 而只绑定了相同的 <code>modle</code> 也会认做是一类单选框的，但是最好还是将 <code>name</code> 写上 </p>
</li>
<li><p>单选框和复选框都可以通过 <code>v-bind:value</code> 绑定的 <code>value</code> 值来设置值自身的 <code>value</code> 值 </p>
</li>
</ul>
</li>
</ul>
<ul>
<li>如果是对选择框 <code>select</code> 进行绑定的 ，绑定的变量的值会随着选中的 option 选项内部的内容而发生变化，如果 <code>option</code> 没有写 <code>value</code> 属性，该变量会变成<code>&lt;option&gt;&lt;/option&gt;</code>内部的值，如果有 <code>value</code> 属性，变量会变成 <code>value</code> 值而不是 <code>option</code> 的内容</li>
</ul>
<pre><code>    &lt;div id=&quot;example&quot;&gt;
        &lt;select v-model=&quot;selected&quot;&gt;
            &lt;option disabled value=&quot;&quot;&gt;请选择&lt;/option&gt;
            &lt;option&gt;A&lt;/option&gt;
            &lt;option&gt;B&lt;/option&gt;
            &lt;option&gt;C&lt;/option&gt;
        &lt;/select&gt;
        &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;
    &lt;/div&gt;
    &lt;script&gt;
        new Vue(&#123;
            el: &#39;#example&#39;，
            data: &#123;
                selected: &#39;&#39;，
            &#125;，
        &#125;)
    &lt;/script&gt;
</code></pre>
<p><strong>注意:</strong><br>在 s 多选时要绑定一个数组，将上方的 <code>selected:[]</code>，这样在选入的时候就能将每个选择的选项的值加到变量中去，还可以是一个对象，但是要通过 <code>v-bind:value</code> 绑定</p>
<h2 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h2><p>该指令不接受任何表达式，使用了该指令的元素 Vue 在编译时跳过这个元素和它的子元素的编译过程，可以用来显示原始的模板<code>&#123;&#123;&#125;&#125;</code>标签，跳过大量没有指令的节点会加快编译</p>
<h2 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h2><p>该指令不需要表达式，<code>只渲染元素和组件一次</code>。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。<br>以后数据的改变不会引起v-once所在结构的更新，这可以用于优化更新性能</p>
<ul>
<li>跳过其所在节点的编译过程。</li>
<li>可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/17/vue/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fangck">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/17/vue/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" class="post-title-link" itemprop="url">Vue 生命周期</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-17 22:14:08 / 修改时间：23:11:55" itemprop="dateCreated datePublished" datetime="2022-09-17T22:14:08+08:00">2022-09-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Vue-生命周期"><a href="#Vue-生命周期" class="headerlink" title="Vue 生命周期"></a>Vue 生命周期</h1><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>又名：生命周期回调函数、生命周期函数、生命周期钩子。</p>
<p>是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数。</p>
<p>生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。</p>
<p>生命周期函数中的this指向是vm 或 组件实例对象。</p>
<p><img src="/images/vue/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F1.png" alt="vue生命周期"></p>
<h2 id="Vue-实例创建阶段"><a href="#Vue-实例创建阶段" class="headerlink" title="Vue 实例创建阶段"></a>Vue 实例创建阶段</h2><ul>
<li><p><code>var vm=new Vue()</code>，创建出一个 Vue 实例对象 </p>
</li>
<li><p><code>beforeCreat</code>，当 Vue 实例被完全创建出来之前，就会执行该函数，这是表示刚初始化了一个空的 Vue 对象，还未进行数据代理</p>
<p>  **注意:**在 beforeCreat 生命周期函数执行的时候，data 和 methods 等中的数据还没有初始化，所以在这里面调用这些 data 或 methods 等中的属性和方法会报错 </p>
</li>
<li><p><code>created</code>，在该函数中，<strong>data 和 methods 等数据已经被初始化好了</strong>，如果要调用 methods 中的方法或者 data 中的数据，最早只能在 created 中进行操作</p>
<p>  **注:**如果要发 Ajax 请求尽量在这个阶段发送 </p>
</li>
<li><p><strong>在这两个生命周期函数之间（create，beforeMount）进行 Vue 的编译模板</strong>，把 Vue 代码中的那些指令进行执行，最终在内存中生成一个编译好的最终模板字符串(虚拟 DOM)，然后把这个字符串渲染为内存中的 DOM，但是此时只是在内存中渲染 DOM，还没有将其挂载到页面中去 </p>
</li>
<li><p><code>beforeMount</code>，在该函数中模板已经在内存中了，但是还没有把模板渲染到页面中，也就是说<code>&#123;&#123;&#125;&#125;</code>中的内容还没有被解析，页面中的元素还没有真正被替换，只是写了一些模板字符串 将内存中的 DOM 挂载到页面中去 </p>
</li>
<li><p><code>mounted</code>，表示内存中的 DOM 已经挂载到页面中了，用户已经可以看到渲染好的页面了 </p>
<p>  注意: mounted 是实例创建期间执行的最后一个生命周期函数，当执行完 mounted 就表示实例已经完全被创建好了 如果要通过某些插件操作页面上的 DOM 节点，最早要在 mounted 中进行</p>
</li>
</ul>
<h2 id="Vue-实例运行阶段"><a href="#Vue-实例运行阶段" class="headerlink" title="Vue 实例运行阶段"></a>Vue 实例运行阶段</h2><p><strong>下面两个生命周期必须要数据发生改变时才会进行，会根据 data 数据的改变触发 0 次或多次</strong></p>
<ul>
<li><code>beforeUpdate</code>，这个函数表明 Vue 实例在运行时数据已经被更新，而页面还没有被更新的时间节点，当执行该函数时，页面中显示的数据还是没有更新前的数据，而 data 中的数据是最新的，页面还没有和数据实现同步 </li>
</ul>
<ul>
<li>**在这两个函数之间(beforeUpdate， updated)**，会根据 data 中的最新数据，重新渲染出一份最新的内存 DOM 树(虚拟DOM)，当最新的内存 DOM 树被更新之后，会把最新的内存 DOM 树重新渲染到真实的页面中去，完成数据从 data 到页面视图的更新 </li>
</ul>
<ul>
<li><code>updated</code>，当这个函数执行时证明 data 中的数据已经和页面中的数据保存同步更新了</li>
</ul>
<h2 id="Vue-实例销毁阶段"><a href="#Vue-实例销毁阶段" class="headerlink" title="Vue 实例销毁阶段"></a>Vue 实例销毁阶段</h2><ul>
<li><code>beforeDestroy</code>， 当执行该函数时，Vue 实例就已经从运行阶段进入到了销毁阶段，实例上的所以属性如 data，methods 等都还是处于可用状态，还没有真正的执行销毁 </li>
<li></li>
<li><code>destroyed</code>，当执行到该函数时，Vue 实例已经被完全销毁，此时所有实例中的属性都不可用了</li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li><p>常用的生命周期钩子：</p>
<ol>
<li><code>mounted</code>: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。</li>
<li><code>beforeDestroy</code>: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。</li>
</ol>
</li>
<li><p>关于销毁Vue实例</p>
<ol>
<li>销毁后借助Vue开发者工具看不到任何信息。</li>
<li>销毁后自定义事件会失效，但原生DOM事件依然有效。</li>
<li>一般不会在<code>beforeDestroy</code>操作数据，因为即便操作数据，也不会再触发更新流程了。</li>
</ol>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/29/vue/Vue%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fangck">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/29/vue/Vue%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">Vue实例对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-29 23:58:08" itemprop="dateCreated datePublished" datetime="2022-07-29T23:58:08+08:00">2022-07-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-17 23:22:23" itemprop="dateModified" datetime="2022-09-17T23:22:23+08:00">2022-09-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Vue实例对象"><a href="#Vue实例对象" class="headerlink" title="Vue实例对象"></a>Vue实例对象</h1><h2 id="创建并绑定-Vue-对象"><a href="#创建并绑定-Vue-对象" class="headerlink" title="创建并绑定 Vue 对象"></a>创建并绑定 Vue 对象</h2><p>Vue 也是一个构造函数,通过 <code>new Vue()</code>可以创建一个 Vue 对象,通过 Vue 对象进行对 DOM 元素以及内部的子孙元素的操作</p>
<pre><code>    new Vue(&#123;
        el: &#39;#div&#39;,
        /*
        在Vue中通过el属性来绑定一个DOM元素,从而让该DOM元素以及内部都绑定Vue的相关操作,一般是通过ID进行查找,因为这样才能够精确绑定
        */
        data: &#123;
            //data属性中包含着在el中使用的使用的变量或属性
            msg: 123,
        &#125;,
        //也可以使用函数形式的
        data() &#123;
            return &#123;
                msg: 123,
            &#125;
        &#125;,
        //methods属性包含着需要使用的方法
        methods: &#123;
            show() &#123;
                console.log(this.msg)
            &#125;,
        &#125;,
    &#125;)
</code></pre>
<p><strong>注:在实例内部使用定义的属性或方法时不能直接使用,必须通过 <code>this</code> 来指定需要用的属性</strong></p>
<h2 id="vue-实例中的参数与选项"><a href="#vue-实例中的参数与选项" class="headerlink" title="vue 实例中的参数与选项"></a>vue 实例中的参数与选项</h2><ul>
<li><code>el:&quot;#id&quot;</code>, //DOM 成员（1/3）<br>  提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。</li>
</ul>
<ul>
<li><code>template:&quot;&lt;tag&gt;&lt;/tag&gt;&quot;</code>, //DOM 成员（2/3）<br>  一个字符串模板作为 Vue 实例的标识使用。模板将会 替换 挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发 </li>
</ul>
<ul>
<li><p><code>slot render: (h)=&gt;&#123;h(App)&#125;</code>, //DOM 成员（3/3）<br>  字符串模板的代替方案，允许你发挥 JavaScript 最大的编程能力。 </p>
<pre><code>  // 原理 
  render: (h) =&gt; &#123; 
      return &lt;APP&gt;&lt;/APP&gt;
  &#125; // 可以代替components和template
</code></pre>
</li>
<li><p><code>data</code> //数据成员（1/6） </p>
<pre><code>  data():&#123; return&#123; &#125; &#125;
</code></pre>
<p>  Vue 实例的数据对象。Vue 将会递归将 <code>data</code> 的属性转换为 <code>getter/setter</code>，从而让 <code>data</code> 的属性能够响应数据变化</p>
</li>
<li><p><code>methods</code> //数据成员（2/6） </p>
<pre><code>  methods:&#123; func()&#123; &#125; &#125; 
</code></pre>
<p>  <code>methods</code> 将被混入到 Vue 实例中，可以直接通过 <code>VM</code> 实例访问这些方法，或者在指令表达式中使用 方法中的 <code>this</code> 自动绑定为 Vue 实例</p>
</li>
<li><p><code>watch</code> //数据成员（3/6） </p>
<pre><code>  watch: &#123; 
      key: value,
      $route(newValue, oldValue) &#123;//监控路由&#125; 
  &#125;
</code></pre>
<p>  Vue的监视属性，整个为一个对象，键是需要观察的表达式，值是对应回调函数 </p>
</li>
<li><p><code>computed</code> //数据成员（4/6） </p>
<pre><code>  computed: &#123;
      getTotalCount() &#123;
          const totalCount = 0
          return totalCount
      &#125;,
  &#125;
</code></pre>
<p>  vue 的计算属性，将被混入到 Vue 实例中。所有 <code>getter</code> 和 <code>setter</code> 的 <code>this</code> 上下文自动地绑定为 Vue 实例 </p>
</li>
<li><p><code>props</code> //数据成员（5/6） </p>
<pre><code>  props:[&#39;counts&#39;,&#39;ids&#39;]
</code></pre>
<p>  用于父子组件的 <code>eventbus</code> 传值，是数组或对象，<code>props</code> 的成员是子组件接收的来自父组件的数据 </p>
</li>
<li><p><code>propsData</code> //数据成员（6/6）<br>  创建实例时传递 <code>props</code>。主要作用是方便测试。基本不使用。</p>
</li>
<li><p><code>filters</code> //资源（1/3） </p>
<pre><code>  filters(
      &#39;filterName&#39;,
      (input,
      function () &#123;
          return newvalue
      &#125;)
  )
</code></pre>
<p>  包含 Vue 实例可用过滤器的哈希表。 </p>
</li>
<li><p><code>directives</code> //资源（2/3）<br>  包含 Vue 实例可用指令的哈希表。 </p>
</li>
<li><p><code>components</code> //资源（3/3）<br>  （即该组件的子实例）这里是包含 Vue 实例可用组件的哈希表。 </p>
</li>
<li><p><code>name</code> //杂项（1/6）<br>  允许组件模板递归地调用自身。注意，组件在全局用 <code>Vue.component()</code> 注册时，全局 ID 自动作为组件的 <code>name</code>。</p>
</li>
<li><p><code>parent</code> //杂项（2/6）<br>  指定已创建的实例之父实例，在两者之间建立父子关系。子实例可以用 <code>this.$parent</code> 访问父实例，子实例被推入父实例的 <code>$children</code> 数组中。 </p>
</li>
<li><p><code>mixins</code> //杂项（3/6）<br>  <code>mixins</code> 选项接受一个混合对象的数组。Mixin 钩子按照传入顺序依次调用,并在调用组件自身的钩子之前被调用。 </p>
</li>
<li><p><code>extends</code> //杂项（4/6）<br>  允许声明扩展另一个组件。这主要是为了便于扩展单文件组件。这和 <code>mixins</code> 类似，区别在于，组件自身的选项会比要扩展的源组件具有更高的优先级。 </p>
</li>
<li><p><code>delimiters</code> //杂项（5/6）<br>  改变纯文本插入分隔符。 </p>
</li>
<li><p><code>functional</code> //杂项（6/6）<br>  使组件无状态（没有 <code>data</code> ）和无实例（没有 <code>this</code> 上下</p>
</li>
</ul>
<h2 id="常用指令实例"><a href="#常用指令实例" class="headerlink" title="常用指令实例"></a>常用指令实例</h2><pre><code>    &lt;!DOCTYPE html&gt;
    &lt;html lang=&quot;en&quot;&gt;
        &lt;head&gt;
            &lt;meta charset=&quot;UTF-8&quot; /&gt;
            &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
            &lt;title&gt;startVue&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;div id=&quot;app&quot;&gt;
                &lt;!-- &#123;&#123;&#125;&#125;双大括号表达式，里面是js代码 -->
		            <p>&#123;&#123; msg &#125;&#125;&lt;/p&gt;

                &lt;!-- 相当于innerText --&gt;
                &lt;p v-text=&quot;str&quot;&gt;&lt;/p&gt;

                &lt;!-- 相当于innerHTML --&gt;
                &lt;p v-html=&quot;str&quot;&gt;&lt;/p&gt;

                &lt;!-- 强制绑定事件, 一般用于用于响应式地更新HTML attribute, 简写方式:
                从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数
                &lt;a v-bind:[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;
                这里的 attributeName 会被作为一个 JavaScript 表达式进行动态求值,求得的值将会作为最终的参数来使用。
                例如，如果你的 Vue 实例有一个 data 属性 attributeName，其值为 &quot;href&quot;
                那么这个绑定将等价于 v-bind:href--&gt;
                &lt;a v-bind:href=&quot;url&quot;&gt;Baidu&lt;/a&gt;

                &lt;!-- 绑定事件监听,监听 DOM 事件, 简写方式@ --&gt;
                &lt;button v-on:click=&quot;test&quot;&gt;Submit&lt;/button&gt;

                &lt;!-- 双向绑定事件,动态实时更新里面的内容 --&gt;
                &lt;div&gt;
                    &lt;input type=&quot;text&quot; v-model=&quot;input&quot; placeholder=&quot;Please input&quot; /&gt;
                    &lt;p&gt;&#123;&#123; input &#125;&#125;&lt;/p&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/body&gt;
        &lt;script text=&quot;javascript&quot; src=&quot;./vue.js&quot;&gt;&lt;/script&gt;
        &lt;script text=&quot;javascript&quot;&gt;
            const app = new Vue(&#123;
                //要挂载的位置
                //在Vue中通过el属性来绑定一个DOM元素,从而让该DOM元素以及内部都绑定Vue的相关操作
                //一般是通过ID进行查找,因为这样才能够精确绑定
                el: &#39;#app&#39;, // data属性中包含着在el中使用的使用的变量或属性
                data: &#123;
                    msg: &#39;xhw&#39;,
                    str: &#39;&lt;a href=&quot;#&quot;&gt;XHW&lt;/a&gt;&#39;,
                    url: &#39;https://www.baidu.com&#39;,
                    input: &#39;&#39;,
                &#125;, // methods属性包含着需要使用的方法
                /**
                 * 也可以写成(以组件形式里必须写成这个)
                 * data() &#123;
                 *     return &#123;
                 *
                 * &#125;
                 * &#125;,
                 */ methods: &#123;
                    test() &#123;
                        alert(&#39;!!!&#39;)
                    &#125;,
                &#125;,
            &#125;)
        &lt;/script&gt;
    &lt;/html&gt;
</p></code></pre>
<h2 id="vm-mount"><a href="#vm-mount" class="headerlink" title="vm.$mount"></a><code>vm.$mount</code></h2><p>如果 Vue 实例在实例化时没有收到 <code>el</code> 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。可以使用 <code>vm.$mount()</code> 手动地挂载一个未挂载的实例</p>
<p>**注意:**这个方法返回实例自身,因而可以链式调用其它实例方法</p>
<pre><code>    var MyComponent = Vue.extend(&#123; template: &#39;&lt;div&gt;Hello!&lt;/div&gt;&#39; &#125;) // 创建并挂载到 #app (会替换 #app)
    new MyComponent().$mount(&#39;#app&#39;) // 同上
    new MyComponent(&#123; el: &#39;#app&#39; &#125;) // 或者，在文档之外渲染并且随后挂载 var
    component = new MyComponent().$mount()
    document.getElementById(&#39;app&#39;).appendChild(component.$el)
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/26/ES6/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fangck">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/26/ES6/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/" class="post-title-link" itemprop="url">字符串的扩展</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-26 21:19:08 / 修改时间：22:57:09" itemprop="dateCreated datePublished" datetime="2022-07-26T21:19:08+08:00">2022-07-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ES6/" itemprop="url" rel="index"><span itemprop="name">ES6</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h1><h2 id="字符的-Unicode-表示法"><a href="#字符的-Unicode-表示法" class="headerlink" title="字符的 Unicode 表示法"></a>字符的 Unicode 表示法</h2><p>JavaScript 允许采用<code>\uxxxx</code>形式表示一个字符，其中<code>xxxx</code>表示字符的 Unicode 码点。</p>
<pre><code>    &#39;\u0061&#39;
    // &quot;a&quot;
</code></pre>
<p>但是，这种表示法只限于码点在<code>\u0000~\uFFFF</code>之间的字符。超出这个范围的字符，必须用两个双字节的形式表示</p>
<p>ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符</p>
<pre><code>    &#39;\u&#123;20BB7&#125;&#39;
    // &quot;𠮷&quot;

    &#39;\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;&#39;
    // &quot;ABC&quot;

    let hello = 123
    hello // 123

    &#39;\u&#123;1F680&#125;&#39; === &#39;\uD83D\uDE80&#39;
    // true
</code></pre>
<p>上面代码中，最后一个例子表明，大括号表示法与四字节的 UTF-16 编码是等价的。</p>
<p>有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符</p>
<pre><code>    &#39;z&#39; === &#39;z&#39; // true
    &#39;\172&#39; === &#39;z&#39; // true
    &#39;\x7A&#39; === &#39;z&#39; // true
    &#39;\u007A&#39; === &#39;z&#39; // true
    &#39;\u&#123;7A&#125;&#39; === &#39;z&#39; // true
</code></pre>
<h2 id="codePointAt"><a href="#codePointAt" class="headerlink" title="codePointAt()"></a>codePointAt()</h2><p>JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符(Unicode 码点大于<code>0xFFFF</code>的字符)，JavaScript 会认为它们是两个字符</p>
<pre><code>    var s = &#39;𠮷&#39;

    s.length // 2
    s.charAt(0) // &#39;&#39;
    s.charAt(1) // &#39;&#39;
    s.charCodeAt(0) // 55362
    s.charCodeAt(1) // 57271
</code></pre>
<p>上面代码中，汉字“𠮷”(注意，这个字不是“吉祥”的“吉”)的码点是<code>0x20BB7</code>，UTF-16 编码为<code>0xD842 0xDFB7</code>(十进制为<code>55362 57271</code>)，需要4个字节储存。对于这种4个字节的字符，JavaScript 不能正确处理，字符串长度会误判为2，而且<code>charAt</code>方法无法读取整个字符，<code>charCodeAt</code>方法只能分别返回前两个字节和后两个字节的值</p>
<p>ES6 提供了<code>codePointAt</code>方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。</p>
<pre><code>    let s = &#39;𠮷a&#39;

    s.codePointAt(0) // 134071
    s.codePointAt(1) // 57271

    s.codePointAt(2) // 97
</code></pre>
<p><code>codePointAt</code>方法的参数，是字符在字符串中的位置(从 0 开始)。上面代码中，JavaScript 将“<code>𠮷 a</code>”视为三个字符，<code>codePointAt</code> 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 <code>134071</code>(即十六进制的<code>20BB7</code>)。在第二个字符(即“𠮷”的后两个字节)和第三个字符“a”上，<code>codePointAt</code>方法的结果与<code>charCodeAt</code>方法相同。 </p>
<p>总之，<code>codePointAt</code>方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与charCodeAt方法相同。 </p>
<p><code>codePointAt</code>方法返回的是码点的十进制值，如果想要十六进制的值，可以使用<code>toString</code>方法转换一下。</p>
<pre><code>    let s = &#39;𠮷a&#39;

    s.codePointAt(0).toString(16) // &quot;20bb7&quot;
    s.codePointAt(2).toString(16) // &quot;61&quot;
</code></pre>
<p>您可能注意到了，<code>codePointAt</code>方法的参数，仍然是不正确的。比如，上面代码中，字符a在字符串s的正确位置序号应该是 1，但是必须向<code>codePointAt</code>方法传入 2。解决这个问题的一个办法是使用<code>for...of</code>循环，因为它会正确识别 32 位的 UTF-16 字符</p>
<pre><code>    let s = &#39;𠮷a&#39;
    for (let ch of s) &#123;
        console.log(ch.codePointAt(0).toString(16))
    &#125;
    // 20bb7
    // 6
</code></pre>
<h2 id="String-fromCodePoint"><a href="#String-fromCodePoint" class="headerlink" title="String.fromCodePoint()"></a>String.fromCodePoint()</h2><p>ES5 提供<code>String.fromCharCode</code>方法，用于从码点返回对应字符，但是这个方法不能识别 32 位的 UTF-16 字符(Unicode 编号大于<code>0xFFFF</code>)。</p>
<pre><code>    String.fromCharCode(0x20bb7)
    // &quot;ஷ&quot;
</code></pre>
<p>上面代码中，<code>String.fromCharCode</code>不能识别大于<code>0xFFFF</code>的码点，所以<code>0x20BB7</code>就发生了溢出，最高位2被舍弃了，最后返回码点<code>U+0BB7</code>对应的字符，而不是码点<code>U+20BB7</code>对应的字符。 </p>
<p>ES6 提供了<code>String.fromCodePoint</code>方法，可以识别大于<code>0xFFFF</code>的字符，弥补了<code>String.fromCharCode</code>方法的不足。在作用上，正好与<code>codePointAt</code>方法相反。</p>
<pre><code>    String.fromCodePoint(0x20bb7)
    // &quot;𠮷&quot;
    String.fromCodePoint(0x78, 0x1f680, 0x79) === &quot;x\uD83D\uDE80y&quot;
    // true
</code></pre>
<p>上面代码中，如果<code>String.fromCodePoint</code>方法有多个参数，则它们会被合并成一个字符串返回。 </p>
<p>注意，<code>fromCodePoint</code>方法定义在<code>String</code>对象上，而<code>codePointAt</code>方法定义在字符串的实例对象上</p>
<h2 id="字符串的遍历器接口"><a href="#字符串的遍历器接口" class="headerlink" title="字符串的遍历器接口"></a>字符串的遍历器接口</h2><p>ES6 为字符串添加了遍历器接口，使得字符串可以被<code>for...of</code>循环遍历。</p>
<pre><code>    for (let codePoint of &#39;foo&#39;) &#123;
        console.log(codePoint)
    &#125;
    // &quot;f&quot;
    // &quot;o&quot;
    // &quot;o&quot;
</code></pre>
<p>除了遍历字符串，这个遍历器最大的优点是可以识别大于<code>0xFFFF</code>的码点，传统的<code>for</code>循环无法识别这样的码点</p>
<pre><code>    let text = String.fromCodePoint(0x20bb7)

    for (let i = 0; i &lt; text.length; i++) &#123;
        console.log(text[i])
    &#125;
    // &quot; &quot;
    // &quot; &quot;

    for (let i of text) &#123;
        console.log(i)
    &#125;
    // &quot;𠮷&quot;
</code></pre>
<p>上面代码中，字符串<code>text</code>只有一个字符，但是<code>for</code>循环会认为它包含两个字符(都不可打印)，而<code>for...of</code>循环会正确识别出这一个字符</p>
<h2 id="includes-startsWith-endsWith"><a href="#includes-startsWith-endsWith" class="headerlink" title="includes(), startsWith(), endsWith()"></a>includes(), startsWith(), endsWith()</h2><p>传统上，JavaScript 只有<code>indexOf</code>方法，可以用来确定一个字符串是否包含在另一个字符串中。<br>ES6 又提供了三种新方法。 </p>
<ul>
<li><p><code>includes()</code>: 返回布尔值，表示是否找到了参数字符串。 </p>
</li>
<li><p><code>startsWith()</code>: 返回布尔值，表示参数字符串是否在原字符串的头部。 </p>
</li>
<li><p><code>endsWith()</code>: 返回布尔值，表示参数字符串是否在原字符串的尾部</p>
<pre><code>  let s = &#39;Hello world!&#39;

  s.startsWith(&#39;Hello&#39;) // true
  s.endsWith(&#39;!&#39;) // true
  s.includes(&#39;o&#39;) // true
</code></pre>
</li>
</ul>
<p>这三个方法都支持第二个参数，表示开始搜索的位置</p>
<pre><code>    let s = &#39;Hello world!&#39;

    s.startsWith(&#39;world&#39;, 6) // true
    s.endsWith(&#39;Hello&#39;, 5) // true
    s.includes(&#39;Hello&#39;, 6) // false
</code></pre>
<p>上面代码表示，使用第二个参数n时，<code>endsWith</code>的行为与其他两个方法有所不同。它针对前<code>n</code>个字符，而其他两个方法针对从第<code>n</code>个位置直到字符串结束</p>
<h2 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h2><p><code>repeat</code>方法返回一个新字符串，表示将原字符串重复<code>n</code>次。</p>
<pre><code>    &#39;x&#39;.repeat(3) // &quot;xxx&quot;
    &#39;hello&#39;.repeat(2) // &quot;hellohello&quot;
    &#39;na&#39;.repeat(0) // &quot;&quot;
</code></pre>
<p>参数如果是小数，会被取整。</p>
<pre><code>    &quot;na&quot;.repeat(2.9) // &quot;nana&quot;
</code></pre>
<p>如果<code>repeat</code>的参数是负数或者<code>Infinity</code>，会报错</p>
<pre><code>    &#39;na&#39;.repeat(Infinity)
    // RangeError
    &#39;na&#39;.repeat(-1)
    // RangeError
</code></pre>
<p>但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，<code>repeat</code>视同为 0</p>
<pre><code>    &quot;na&quot;.repeat(-0.9) // &quot;&quot;
</code></pre>
<p>参数NaN等同于 0。 </p>
<pre><code>    &quot;na&quot;.repeat(NaN); // &quot;&quot;
</code></pre>
<p>如果<code>repeat</code>的参数是字符串，则会先转换成数字。 </p>
<pre><code>    &quot;na&quot;.repeat(&quot;na&quot;) // &quot;&quot;
    &quot;na&quot;.repeat(&quot;3&quot;) // &quot;nanana&quot;
</code></pre>
<h2 id="padStart-，padEnd"><a href="#padStart-，padEnd" class="headerlink" title="padStart()，padEnd()"></a>padStart()，padEnd()</h2><p>ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。<br><code>padStart()</code>用于头部补全，<code>padEnd()</code>用于尾部补全</p>
<pre><code>    &quot;x&quot;.padStart(5, &quot;ab&quot;) // &#39;ababx&#39;
    &quot;x&quot;.padStart(4, &quot;ab&quot;) // &#39;abax&#39;
    
    &quot;x&quot;.padEnd(5, &quot;ab&quot;) // &#39;xabab&#39;
    &quot;x&quot;.padEnd(4, &quot;ab&quot;) // &#39;xaba&#39;
</code></pre>
<p>上面代码中，<code>padStart</code>和<code>padEnd</code>一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。</p>
<p>如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串</p>
<pre><code>    &#39;xxx&#39;.padStart(2, &#39;ab&#39;) // &#39;xxx&#39;
    &#39;xxx&#39;.padEnd(2, &#39;ab&#39;) // &#39;xxx&#39;
</code></pre>
<p>如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串</p>
<pre><code>    &#39;abc&#39;.padStart(10, &#39;0123456789&#39;)
    // &#39;0123456abc&#39;
</code></pre>
<p>如果省略第二个参数，默认使用空格补全长度</p>
<pre><code>    &#39;x&#39;.padStart(4) // &#39;   x&#39;
    &#39;x&#39;.padEnd(4) // &#39;x   &#39;
</code></pre>
<p><code>padStart</code>的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串</p>
<pre><code>    &#39;1&#39;.padStart(10, &#39;0&#39;) // &quot;0000000001&quot;
    &#39;12&#39;.padStart(10, &#39;0&#39;) // &quot;0000000012&quot;
    &#39;123456&#39;.padStart(10, &#39;0&#39;) // &quot;0000123456&quot;
</code></pre>
<p>另一个用途是提示字符串格式。</p>
<pre><code>    &#39;12&#39;.padStart(10, &#39;YYYY-MM-DD&#39;) // &quot;YYYY-MM-12&quot;
    &#39;09-12&#39;.padStart(10, &#39;YYYY-MM-DD&#39;) // &quot;YYYY-09-12&quot;
</code></pre>
<h2 id="matchAll"><a href="#matchAll" class="headerlink" title="matchAll()"></a>matchAll()</h2><p><code>matchAll</code>方法返回一个正则表达式在当前字符串的所有匹配</p>
<h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>传统的 JavaScript 语言，输出模板通常是这样写的(下面使用了 jQuery 的方法)。</p>
<pre><code>    $(&#39;#result&#39;).append(
        &#39;There are &lt;b&gt;&#39; +
            basket.count +
            &#39;&lt;/b&gt; &#39; +
            &#39;items in your basket, &#39; +
            &#39;&lt;em&gt;&#39; +
            basket.onSale +
            &#39;&lt;/em&gt; are on sale!&#39;
    )
</code></pre>
<p>上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。</p>
<pre><code>    $(&#39;#result&#39;).append(`
        There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items
        in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt;
        are on sale!
    `)
</code></pre>
<p>模板字符串(template string)是增强版的字符串，用反引号(```)标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量</p>
<pre><code>    // 普通字符串
    ;`In JavaScript &#39;\n&#39; is a line-feed.` // 多行字符串
    `In JavaScript this is not legal.`

    console.log(`string text line 1 string text line 2`)

    // 字符串中嵌入变量
    let name = &#39;Bob&#39;,
        time = &#39;today&#39;
    ;`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 
        // Hello Bob, how are you today?
</code></pre>
<p>上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</p>
<pre><code>    let greeting = `\`Yo\` World!`
</code></pre>
<p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。</p>
<pre><code>    $(&quot;#list&quot;).html(`
    &lt;ul&gt;
      &lt;li&gt;first&lt;/li&gt;
      &lt;li&gt;second&lt;/li&gt;
    &lt;/ul&gt;
    `)
</code></pre>
<p>上面代码中，所有模板字符串的空格和换行，都是被保留的，比如<code>&lt;ul&gt;</code>标签前面会有一个换行。如果您不想要这个换行，可以使用<code>trim</code>方法消除它</p>
<pre><code>    $(&quot;#list&quot;).html(
      `
    &lt;ul&gt;
      &lt;li&gt;first&lt;/li&gt;
      &lt;li&gt;second&lt;/li&gt;
    &lt;/ul&gt;
    `.trim()
    )
</code></pre>
<p>模板字符串中嵌入变量，需要将变量名写在<code>$&#123;&#125;</code>之中。</p>
<pre><code>    function authorize(user, action) &#123;
        if (!user.hasPrivilege(action)) &#123;
            throw new Error(
                // 传统写法为
                // &#39;User &#39;
                // + user.name
                // + &#39; is not authorized to do &#39;
                // + action
                // + &#39;.&#39;
                `User $&#123;user.name&#125; is not authorized to do $&#123;action&#125;.`
            )
        &#125;
    &#125;
</code></pre>
<p>大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。</p>
<pre><code>    let x = 1
    let y = 2

    ;`$&#123;x&#125; + $&#123;y&#125; = $&#123;x + y&#125;` // &quot;1 + 2 = 3&quot;
    `$&#123;x&#125; + $&#123;y * 2&#125; = $&#123;x + y * 2&#125;`
    // &quot;1 + 4 = 5&quot;

    let obj = &#123; x: 1, y: 2 &#125;
    ;`$&#123;obj.x + obj.y&#125;`
    // &quot;3&quot;
</code></pre>
<p>模板字符串之中还能调用函数。</p>
<pre><code>    function fn() &#123;
        return &#39;Hello World&#39;
    &#125;

    ;`foo $&#123;fn()&#125; bar`
    // foo Hello World bar
</code></pre>
<p>如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的<code>toString</code>方法</p>
<p>如果模板字符串中的变量没有声明，将报错。</p>
<pre><code>    // 变量place没有声明
    let msg = `Hello, $&#123;place&#125;`
    // 报错
</code></pre>
<p>由于模板字符串的大括号内部，就是执行 JavaScript 代码，因此如果大括号内部是一个字符串，将会原样输出</p>
<pre><code>    `Hello $&#123;&quot;World&quot;&#125;`
    // &quot;Hello World&quot;
</code></pre>
<h2 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h2><p>模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能(tagged template)。</p>
<pre><code>    alert`123`
    // 等同于
    alert(123)
</code></pre>
<p>标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。 </p>
<p>但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。</p>
<pre><code>    let a = 5
    let b = 10

    tag`Hello $&#123;a + b&#125; world $&#123;a * b&#125;`
    // 等同于
    tag([&#39;Hello &#39;, &#39; world &#39;, &#39;&#39;], 15, 50)
</code></pre>
<p>上面代码中，模板字符串前面有一个标识名tag，它是一个函数。整个表达式的返回值，就是tag函数处理模板字符串后的返回值。</p>
<p>函数<code>tag</code>依次会接收到多个参数。</p>
<pre><code>    function tag(stringArr, value1, value2) &#123;
        // ...
    &#125;

    // 等同于

    function tag(stringArr, ...values) &#123;
        // ...
    &#125;
</code></pre>
<p><code>tag</code>函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。 </p>
<p><code>tag</code>函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此<code>tag</code>会接受到<code>value1</code>和<code>value2</code>两个参数。</p>
<p><code>tag</code>函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。 </p>
<p><code>tag</code>函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此<code>tag</code>会接受到<code>value1</code>和<code>value2</code>两个参数。 </p>
<p>tag函数所有参数的实际值如下。 </p>
<ul>
<li>第一个参数: [‘Hello ‘, ‘ world ‘, ‘’] </li>
<li>第二个参数: 15 </li>
<li>第三个参数: 50 </li>
</ul>
<p>也就是说，tag函数实际上以下面的形式调用。</p>
<pre><code>    tag([&quot;Hello &quot;, &quot; world &quot;, &quot;&quot;], 15, 50)
</code></pre>
<p>我们可以按照需要编写<code>tag</code>函数的代码。下面是<code>tag</code>函数的一种写法，以及运行结果。</p>
<pre><code>    let a = 5
    let b = 10

    function tag(s, v1, v2) &#123;
        console.log(s[0])
        console.log(s[1])
        console.log(s[2])
        console.log(v1)
        console.log(v2)

        return &#39;OK&#39;
    &#125;

    tag`Hello $&#123;a + b&#125; world $&#123;a * b&#125;`
    // &quot;Hello &quot;
    // &quot; world &quot;
    // &quot;&quot;
    // 15
    // 50
    // &quot;OK&quot;
</code></pre>
<p>“标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。</p>
<pre><code>    let message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`

    function SaferHTML(templateData) &#123;
        let s = templateData[0]
        for (let i = 1; i &lt; arguments.length; i++) &#123;
            let arg = String(arguments[i])

            // Escape special characters in the substitution.
            s += arg
                .replace(/&amp;/g, &#39;&amp;amp;&#39;)
                .replace(/&lt;/g, &#39;&amp;lt;&#39;)
                .replace(/&gt;/g, &#39;&amp;gt;&#39;)

            // Don&#39;t escape special characters in the template.
            s += templateData[i]
        &#125;
        return s
    &#125;
</code></pre>
<p>上面代码中，<code>sender</code>变量往往是用户提供的，经过<code>SaferHTML</code>函数处理，里面的特殊字符都会被转义。</p>
<pre><code>    let sender = &#39;&lt;script&gt;alert(&quot;abc&quot;)&lt;/script&gt;&#39; // 恶意代码
    let message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`
    
    message
    // &lt;p&gt;&amp;lt;script&amp;gt;alert(&quot;abc&quot;)&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt;
</code></pre>
<h2 id="String-raw"><a href="#String-raw" class="headerlink" title="String.raw()"></a>String.raw()</h2><p>ES6 还为原生的 String 对象，提供了一个<code>raw</code>方法。</p>
<p><code>String.raw</code>方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义(即斜杠前面再加一个斜杠)的字符串，对应于替换变量后的模板字符串</p>
<pre><code>    String.raw`Hi\n$&#123;2 + 3&#125;!`
    // 返回 &quot;Hi\\n5!&quot;

    String.raw`Hi\u000A!`
    // 返回 &quot;Hi\\u000A!&quot;
</code></pre>
<p>如果原字符串的斜杠已经转义，那么<code>String.raw</code>会进行再次转义。</p>
<pre><code>    String.raw`Hi\\n`
    // 返回 &quot;Hi\\\\n&quot;
</code></pre>
<p><code>String.raw</code>方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。 </p>
<p><code>String.raw</code>方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有<code>raw</code>属性的对象，且<code>raw</code>属性的值应该是一个数组。</p>
<pre><code>    String.raw(&#123; raw: &#39;test&#39; &#125;, 0, 1, 2)
    // &#39;t0e1s2t&#39;

    // 等同于
    String.raw(&#123; raw: [&#39;t&#39;, &#39;e&#39;, &#39;s&#39;, &#39;t&#39;] &#125;, 0, 1, 2)
</code></pre>
<p>作为函数，<code>String.raw</code>的代码实现基本如下</p>
<pre><code>    String.raw = function (strings, ...values) &#123;
        let output = &#39;&#39;
        let index
        for (index = 0; index &lt; values.length; index++) &#123;
            output += strings.raw[index] + values[index]
        &#125;

        output += strings.raw[index]
        return output
    &#125;
</code></pre>
<h2 id="模板字符串的限制"><a href="#模板字符串的限制" class="headerlink" title="模板字符串的限制"></a>模板字符串的限制</h2><p>前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，导致无法嵌入其他语言。</p>
<p>举例来说，标签模板里面可以嵌入 LaTEX 语言。</p>
<pre><code>    function latex(strings) &#123;
        // ...
    &#125;

    let document = latex`
        \newcommand&#123;\fun&#125;&#123;\textbf&#123;Fun!&#125;&#125;  // 正常工作
        \newcommand&#123;\unicode&#125;&#123;\textbf&#123;Unicode!&#125;&#125; // 报错
        \newcommand&#123;\xerxes&#125;&#123;\textbf&#123;King!&#125;&#125; // 报错

        Breve over the h goes \u&#123;h&#125;ere // 报错
        `
</code></pre>
<p>上面代码中，变量<code>document</code>内嵌的模板字符串，对于 LaTEX 语言来说完全是合法的，但是 JavaScript 引擎会报错。原因就在于字符串的转义。 </p>
<p>模板字符串会将<code>\u00FF</code>和<code>\u&#123;42&#125;</code>当作 Unicode 字符进行转义，所以解析<code>\unicode</code>时报错；而<code>\x56</code>会被当作十六进制字符串转义，所以<code>\xerxes</code>会报错。<br>也就是说，<code>\u</code>和<code>\x</code>在 LaTEX 里面有特殊含义，但是 JavaScript 将它们转义了。 </p>
<p>为了解决这个问题，ES2018 放松了对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回<code>undefined</code>，而不是报错，并且从<code>raw</code>属性上面可以得到原始字符串。</p>
<pre><code>    function tag(strs) &#123;
        strs[0] === undefined
        strs.raw[0] === &#39;\\unicode and \\u&#123;55&#125;&#39;
    &#125;
    tag`\unicode and \u&#123;55&#125;`
</code></pre>
<p>上面代码中，模板字符串原本是应该报错的，但是由于放松了对字符串转义的限制，所以不报错了，JavaScript 引擎将第一个字符设置为<code>undefined</code>，但是raw属性依然可以得到原始字符串，因此<code>tag</code>函数还是可以对原字符串进行处理。 </p>
<p>注意，这种对字符串转义的放松，只在标签模板解析字符串时生效，不是标签模板的场合，依然会报错</p>
<pre><code>    let bad = `bad escape sequence: \unicode` // 报错
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/23/ES6/Moudle%20%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fangck">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/23/ES6/Moudle%20%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">Module 的加载实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-23 15:58:59 / 修改时间：23:48:48" itemprop="dateCreated datePublished" datetime="2022-07-23T15:58:59+08:00">2022-07-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ES6/" itemprop="url" rel="index"><span itemprop="name">ES6</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Module-的加载实现"><a href="#Module-的加载实现" class="headerlink" title="Module 的加载实现"></a>Module 的加载实现</h1><p>本章介绍如何在浏览器和 Node 之中加载 ES6 模块，以及实际开发中经常遇到的一些问题(比如循环加载)</p>
<h2 id="浏览器加载"><a href="#浏览器加载" class="headerlink" title="浏览器加载"></a>浏览器加载</h2><h3 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h3><p>在 HTML 网页中，浏览器通过<code>&lt;script&gt;</code>标签加载 JavaScript 脚本。</p>
<pre><code>    &lt;!-- 页面内嵌的脚本 --&gt;
    &lt;script type=&quot;application/javascript&quot;&gt;
        // module code
    &lt;/script&gt;

    &lt;!-- 外部脚本 --&gt;
    &lt;script type=&quot;application/javascript&quot; src=&quot;path/to/myModule.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>上面代码中，由于浏览器脚本的默认语言是 JavaScript，因此<code>type=&quot;application/javascript&quot;</code>可以省略</p>
<p>默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到<code>&lt;script&gt;</code>标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间</p>
<p>如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本<code>异步加载</code>，下面就是两种异步加载的语法。</p>
<pre><code>    &lt;script src=&quot;path/to/myModule.js&quot; defer&gt;&lt;/script&gt;
    &lt;script src=&quot;path/to/myModule.js&quot; async&gt;&lt;/script&gt;
</code></pre>
<p>上面代码中，<code>&lt;script&gt;</code>标签打开<code>defer</code>或<code>async</code>属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令</p>
<p>注：<br><code>defer</code>与<code>async</code>的区别是: <code>defer</code>要等到整个页面在内存中正常渲染结束(DOM 结构完全生成，以及其他脚本执行完成)，才会执行；<code>async</code>一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，<code>defer</code>是“渲染完再执行”，<code>async</code>是“下载完就执行”。另外，如果有多个<code>defer</code>脚本，会按照它们在页面出现的顺序加载，而多个<code>async</code>脚本是不能保证加载顺序的</p>
<h3 id="加载规则"><a href="#加载规则" class="headerlink" title="加载规则"></a>加载规则</h3><p>浏览器加载 ES6 模块，也使用<code>&lt;script&gt;</code>标签，但是要加入<code>type=&quot;module&quot;</code>属性</p>
<pre><code>    &lt;script type=&quot;module&quot; src=&quot;./foo.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>上面代码在网页中插入一个模块<code>foo.js</code>，由于<code>type</code>属性设为<code>module</code>，所以浏览器知道这是一个 ES6 模块</p>
<p>浏览器对于带有<code>type=&quot;module&quot;</code>的<code>&lt;script&gt;</code>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<code>&lt;script&gt;</code>标签的<code>defer</code>属性</p>
<pre><code>    &lt;script type=&quot;module&quot; src=&quot;./foo.js&quot;&gt;&lt;/script&gt;
    &lt;!-- 等同于 --&gt;
    &lt;script type=&quot;module&quot; src=&quot;./foo.js&quot; defer&gt;&lt;/script&gt;
</code></pre>
<p>如果网页有多个<code>&lt;script type=&quot;module&quot;&gt;</code>，它们会按照在页面出现的顺序依次执行</p>
<p><code>&lt;script&gt;</code>标签的<code>async</code>属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染</p>
<pre><code>    &lt;script type=&quot;module&quot; src=&quot;./foo.js&quot; async&gt;&lt;/script&gt;
</code></pre>
<p>一旦使用了<code>async</code>属性，<code>&lt;script type=&quot;module&quot;&gt;</code>就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块</p>
<p>ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致</p>
<pre><code>    &lt;script type=&quot;module&quot;&gt;
        import utils from &#39;./utils.js&#39;

        // other code
    &lt;/script&gt;
</code></pre>
<p>对于外部的模块脚本(上例是<code>foo.js</code>)，有几点需要注意</p>
<ul>
<li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。 </li>
<li>模块脚本自动采用严格模式，不管有没有声明<code>use strict</code>。 </li>
<li>模块之中，可以使用<code>import</code>命令加载其他模块(<code>.js</code>后缀不可省略，需要提供绝对 URL 或相对 URL)，也可以使用<code>export</code>命令输出对外接口。 </li>
<li>模块之中，顶层的<code>this</code>关键字返回<code>undefined</code>，而不是指向<code>window</code>。也就是说，在模块顶层使用<code>this</code>关键字，是无意义的。 </li>
<li>同一个模块如果加载多次，将只执行一次。</li>
</ul>
<hr>
<p>下面是一个示例模块。</p>
<pre><code>    import utils from &#39;https://example.com/js/utils.js&#39;

    const x = 1

    console.log(x === window.x) //false
    console.log(this === undefined) // true
</code></pre>
<p>利用顶层的<code>this</code>等于<code>undefined</code>这个语法点，可以侦测当前代码是否在 ES6 模块之中</p>
<pre><code>    const isNotModuleScript = this !== undefined
</code></pre>
<h2 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h2><p>讨论 Node 加载 ES6 模块之前，必须了解 ES6 模块与 CommonJS 模块完全不同。</p>
<p>它们有两个重大差异。</p>
<ul>
<li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li>
<li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li>
</ul>
<p>第二个差异是因为 CommonJS 加载的是一个对象(即<code>module.exports</code>属性)，该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>
<p>下面重点解释第一个差异。</p>
<p>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个模块文件<code>lib.js</code>的例子</p>
<pre><code>    // lib.js
    var counter = 3
    function incCounter() &#123;
        counter++
    &#125;
    module.exports = &#123;
        counter: counter,
        incCounter: incCounter,
    &#125;
</code></pre>
<p>上面代码输出内部变量<code>counter</code>和改写这个变量的内部方法<code>incCounter</code>。然后，在<code>main.js</code>里面加载这个模块</p>
<pre><code>    // main.js
    var mod = require(&quot;./lib&quot;)
    
    console.log(mod.counter) // 3
    mod.incCounter()
    console.log(mod.counter) // 3
</code></pre>
<p>上面代码说明，<code>lib.js</code>模块加载以后，它的内部变化就影响不到输出的<code>mod.counter</code>了。这是因为<code>mod.counter</code>是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值</p>
<pre><code>    // lib.js
    var counter = 3
    function incCounter() &#123;
        counter++
    &#125;
    module.exports = &#123;
        get counter() &#123;
            return counter
        &#125;,
        incCounter: incCounter,
    &#125;
</code></pre>
<p>上面代码中，输出的<code>counter</code>属性实际上是一个取值器函数。现在再执行<code>main.js</code>，就可以正确读取内部变量<code>counter</code>的变动了</p>
<pre><code>    $ node main.js
    3
    4
</code></pre>
<p>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。<br>换句话说，ES6 的<code>import</code>有点像 Unix 系统的“符号连接”，原始值变了，<code>import</code>加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块</p>
<pre><code>    // lib.js
    export let counter = 3
    export function incCounter() &#123;
        counter++
    &#125;

    // main.js
    import &#123; counter, incCounter &#125; from &#39;./lib&#39;
    console.log(counter) // 3
    incCounter()
    console.log(counter) // 4
</code></pre>
<p>上面代码说明，ES6 模块输入的变量<code>counter</code>是活的，完全反应其所在模块<code>lib.js</code>内部的变化。</p>
<hr>
<p>例：<code>m1.js</code>的变量<code>foo</code>，在刚加载时等于bar，过了 500 毫秒，又变为等于baz</p>
<pre><code>    // m1.js
    export var foo = &#39;bar&#39;
    setTimeout(() =&gt; (foo = &#39;baz&#39;), 500)

    // m2.js
    import &#123; foo &#125; from &#39;./m1.js&#39;
    console.log(foo)
    setTimeout(() =&gt; console.log(foo), 500)
</code></pre>
<p>上面代码中，<code>m1.js</code>的变量<code>foo</code>，在刚加载时等于<code>bar</code>，过了 500 毫秒，又变为等于<code>baz</code></p>
<p>让我们看看，<code>m2.js</code>能否正确读取这个变化</p>
<pre><code>    $ babel-node m2.js
    
    bar
    baz
</code></pre>
<p>上面代码表明，ES6 模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块</p>
<p>由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错</p>
<pre><code>    // lib.js
    export let obj = &#123;&#125;

    // main.js
    import &#123; obj &#125; from &#39;./lib&#39;

    obj.prop = 123 // OK
    obj = &#123;&#125; // TypeError
</code></pre>
<p>上面代码中，<code>main.js</code>从<code>lib.js</code>输入变量<code>obj</code>，可以对<code>obj</code>添加属性，但是重新赋值就会报错。因为变量<code>obj</code>指向的地址是只读的，不能重新赋值，这就好比<code>main.js</code>创造了一个名为<code>obj</code>的<code>const</code>变量。 </p>
<p>最后，<code>export</code>通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例</p>
<pre><code>    // mod.js
    function C() &#123;
        this.sum = 0
        this.add = function () &#123;
            this.sum += 1
        &#125;
        this.show = function () &#123;
            console.log(this.sum)
        &#125;
    &#125;

    export let c = new C()
</code></pre>
<p>上面的脚本<code>mod.js</code>，输出的是一个<code>C</code>的实例。不同的脚本加载这个模块，得到的都是同一个实例。</p>
<pre><code>    // x.js
    import &#123; c &#125; from &#39;./mod&#39;
    c.add()

    // y.js
    import &#123; c &#125; from &#39;./mod&#39;
    c.show()

    // main.js
    import &#39;./x&#39;
    import &#39;./y&#39;
</code></pre>
<p>现在执行<code>main.js</code>，输出的是1。</p>
<pre><code>    $ babel-node main.js
    1
</code></pre>
<p>这就证明了<code>x.js</code>和<code>y.js</code>加载的都是<code>C</code>的同一个实例</p>
<h2 id="Node-加载"><a href="#Node-加载" class="headerlink" title="Node 加载"></a>Node 加载</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Node 对 ES6 模块的处理比较麻烦，因为它有自己的 CommonJS 模块格式，与 ES6 模块格式是不兼容的。目前的解决方案是，将两者分开，ES6 模块和 CommonJS 采用各自的加载方案。 </p>
<p>Node 要求 ES6 模块采用<code>.mjs</code>后缀文件名。也就是说，只要脚本文件里面使用<code>import</code>或者<code>export</code>命令，那么就必须采用<code>.mjs</code>后缀名。<code>require</code>命令不能加载<code>.mjs</code>文件，会报错，只有<code>import</code>命令才可以加载<code>.mjs</code>文件。反过来，<code>.mjs</code>文件里面也不能使用<code>require</code>命令，必须使用<code>import</code></p>
<p>为了与浏览器的<code>import</code>加载规则相同，Node 的<code>.mjs</code>文件支持 URL 路径</p>
<pre><code>    import &quot;./foo?query=1&quot; // 加载 ./foo 传入参数 ?query=1
</code></pre>
<p>上面代码中，脚本路径带有参数<code>?query=1</code>，Node 会按 URL 规则解读。同一个脚本只要参数不同，就会被加载多次，并且保存成不同的缓存。由于这个原因，只要文件名中含有<code>:</code>、<code>%</code>、<code>#</code>、<code>?</code>等特殊字符，最好对这些字符进行转义。 </p>
<p>目前，Node 的<code>import</code>命令只支持加载本地模块(<code>file:</code>协议)，不支持加载远程模块。 如果模块名不含路径，那么<code>import</code>命令会去<code>node_modules</code>目录寻找这个模块</p>
<pre><code>    import &#39;baz&#39;
    import &#39;abc/123&#39;
</code></pre>
<p>如果模块名包含路径，那么<code>import</code>命令会按照路径去寻找这个名字的脚本文件</p>
<pre><code>    import &#39;file:///etc/config/app.json&#39;
    import &#39;./foo&#39;
    import &#39;./foo?search&#39;
    import &#39;../bar&#39;
    import &#39;/baz&#39;
</code></pre>
<p>如果脚本文件省略了后缀名，比如<code>import &#39;./foo&#39;</code>，Node 会依次尝试四个后缀名: <code>./foo.mjs</code>、<code>./foo.js</code>、<code>./foo.json</code>、<code>./foo.node</code>。如果这些脚本文件都不存在，Node 就会去加载<code>./foo/package.json</code>的<code>main</code>字段指定的脚本。<br>如果<code>./foo/package.json</code>不存在或者没有main字段，那么就会依次加载<code>./foo/index.mjs</code>、<code>./foo/index.js</code>、<code>./foo/index.json</code>、<code>./foo/index.node</code>。如果以上四个文件还是都不存在，就会抛出错误。 </p>
<p>最后，Node 的<code>import</code>命令是异步加载，这一点与浏览器的处理方法相同</p>
<h3 id="内部变量"><a href="#内部变量" class="headerlink" title="内部变量"></a>内部变量</h3><p>ES6 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。为了达到这个目标，Node 规定 ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量。 </p>
<p>首先，就是<code>this</code>关键字。ES6 模块之中，顶层的<code>this</code>指向<code>undefined</code>；CommonJS 模块的顶层<code>this</code>指向当前模块，这是两者的一个重大差异。</p>
<p>其次，以下这些顶层变量在 ES6 模块之中都是不存在的</p>
<ul>
<li><code>arguments</code> </li>
<li><code>require</code></li>
<li><code>module</code></li>
<li><code>exports</code></li>
<li><code>__filename</code></li>
<li><code>__dirname</code></li>
</ul>
<p>如果您一定要使用这些变量，有一个变通方法，就是写一个 CommonJS 模块输出这些变量，然后再用 ES6 模块加载这个 CommonJS 模块。但是这样一来，该 ES6 模块就不能直接用于浏览器环境了，所以不推荐这样做</p>
<pre><code>    // expose.js
    module.exports = &#123; __dirname &#125;

    // use.mjs
    import expose from &#39;./expose.js&#39;
    const &#123; __dirname &#125; = expose
</code></pre>
<p>上面代码中，<code>expose.js</code>是一个 CommonJS 模块，输出变量<code>__dirname</code>，该变量在 ES6 模块之中不存在。ES6 模块加载<code>expose.js</code>，就可以得到<code>__dirname</code></p>
<h3 id="ES6-模块加载-CommonJS-模块"><a href="#ES6-模块加载-CommonJS-模块" class="headerlink" title="ES6 模块加载 CommonJS 模块"></a>ES6 模块加载 CommonJS 模块</h3><p>CommonJS 模块的输出都定义在<code>module.exports</code>这个属性上面。Node 的<code>import</code>命令加载 CommonJS 模块，Node 会自动将<code>module.exports</code>属性，当作模块的默认输出，即等同于<code>export default xxx</code>。</p>
<p>下面是一个 CommonJS 模块。</p>
<pre><code>    // a.js
    module.exports = &#123;
        foo: &#39;hello&#39;,
        bar: &#39;world&#39;,
    &#125;

    // 等同于
    export default &#123;
        foo: &#39;hello&#39;,
        bar: &#39;world&#39;,
    &#125;
</code></pre>
<p><code>import</code>命令加载上面的模块，<code>module.exports</code>会被视为默认输出，<code>即import</code>命令实际上输入的是这样一个对象<code>&#123; default: module.exports &#125;</code>。</p>
<p>所以，一共有三种写法，可以拿到 CommonJS 模块的<code>module.exports</code></p>
<pre><code>    // 写法一
    import baz from &#39;./a&#39;
    // baz = &#123;foo: &#39;hello&#39;, bar: &#39;world&#39;&#125;;

    // 写法二
    import &#123; default as baz &#125; from &#39;./a&#39;
    // baz = &#123;foo: &#39;hello&#39;, bar: &#39;world&#39;&#125;;

    // 写法三
    import * as baz from &#39;./a&#39;
    // baz = &#123;
    //   get default() &#123;return module.exports;&#125;,
    //   get foo() &#123;return this.default.foo&#125;.bind(baz),
    //   get bar() &#123;return this.default.bar&#125;.bind(baz)
    // &#125;
</code></pre>
<h2 id="上面代码的第三种写法，可以通过baz-default拿到module-exports。foo属性和bar属性就是可以通过这种方法拿到了module-exports"><a href="#上面代码的第三种写法，可以通过baz-default拿到module-exports。foo属性和bar属性就是可以通过这种方法拿到了module-exports" class="headerlink" title="上面代码的第三种写法，可以通过baz.default拿到module.exports。foo属性和bar属性就是可以通过这种方法拿到了module.exports"></a>上面代码的第三种写法，可以通过<code>baz.default</code>拿到<code>module.exports</code>。<code>foo</code>属性和<code>bar</code>属性就是可以通过这种方法拿到了<code>module.exports</code></h2><p>下面是一些例子</p>
<pre><code>    // b.js
    module.exports = null

    // es.js
    import foo from &#39;./b&#39;
    // foo = null

    import * as bar from &#39;./b&#39;
    // bar = &#123; default:null &#125;
</code></pre>
<p>上面代码中，<code>es.js</code>采用第二种写法时，要通过<code>bar.default</code>这样的写法，才能拿到<code>module.exports</code>。</p>
<pre><code>    // c.js
    module.exports = function two() &#123;
        return 2
    &#125;

    // es.js
    import foo from &#39;./c&#39;
    foo() // 2

    import * as bar from &#39;./c&#39;
    bar.default() // 2
    bar() // throws, bar is not a function
</code></pre>
<p>上面代码中，<code>bar</code>本身是一个对象，不能当作函数调用，只能通过<code>bar.default</code>调用。</p>
<p>CommonJS 模块的输出缓存机制，在 ES6 加载方式下依然有效</p>
<pre><code>    // foo.js
    module.exports = 123
    setTimeout((_) =&gt; (module.exports = null))
</code></pre>
<p>上面代码中，对于加载<code>foo.js</code>的脚本，<code>module.exports</code>将一直是<code>123</code>，而不会变成<code>null</code>。 </p>
<p>由于 ES6 模块是编译时确定输出接口，CommonJS 模块是运行时确定输出接口，所以采用<code>import</code>命令加载 CommonJS 模块时，不允许采用下面的写法。</p>
<pre><code>    // 不正确
    import &#123; readFile &#125; from &quot;fs&quot;
</code></pre>
<p>上面的写法不正确，因为<code>fs</code>是 CommonJS 格式，只有在运行时才能确定<code>readFile</code>接口，而<code>import</code>命令要求编译时就确定这个接口。解决方法就是改为整体输入</p>
<pre><code>    // 正确的写法一
    import * as express from &#39;express&#39;
    const app = express.default()

    // 正确的写法二
    import express from &#39;express&#39;
    const app = express()
</code></pre>
<h3 id="CommonJS-模块加载-ES6-模块"><a href="#CommonJS-模块加载-ES6-模块" class="headerlink" title="CommonJS 模块加载 ES6 模块"></a>CommonJS 模块加载 ES6 模块</h3><p>CommonJS 模块加载 ES6 模块，不能使用<code>require</code>命令，而要使用<code>import()</code>函数。ES6 模块的所有输出接口，会成为输入对象的属性</p>
<pre><code>    // es.mjs
    let foo = &#123; bar: &#39;my-default&#39; &#125;
    export default foo

    // cjs.js
    const es_namespace = await import(&#39;./es.mjs&#39;)
    // es_namespace = &#123;
    //     get default() &#123;&#125;,
    // &#125;
    console.log(es_namespace.default)
    // &#123; bar:&#39;my-default&#39; &#125;
</code></pre>
<p>上面代码中，<code>default</code>接口变成了<code>es_namespace.default</code>属性</p>
<hr>
<p>下面是另一个例子</p>
<pre><code>    // es.js
    export let foo = &#123; bar: &#39;my-default&#39; &#125;
    export &#123; foo as bar &#125;
    export function f() &#123;&#125;
    export class c &#123;&#125;

    // cjs.js
    const es_namespace = await import(&#39;./es&#39;)
    // es_namespace = &#123;
    //     get foo() &#123;
    //         return foo
    //     &#125;,
    //     get bar() &#123;
    //         return foo
    //     &#125;,
    //     get f() &#123;
    //         return f
    //     &#125;,
    //     get c() &#123;
    //         return c
    //     &#125;,
    // &#125;
</code></pre>
<h2 id="循环加载"><a href="#循环加载" class="headerlink" title="循环加载"></a>循环加载</h2><p>“循环加载”(circular dependency)指的是，<code>a</code>脚本的执行依赖<code>b</code>脚本，而<code>b</code>脚本的执行又依赖<code>a</code>脚本</p>
<pre><code>    // a.js
    var b = require(&#39;b&#39;)

    // b.js
    var a = require(&#39;a&#39;)
</code></pre>
<p>通常，“循环加载”表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。 </p>
<p>但是实际上，这是很难避免的，尤其是依赖关系复杂的大项目，很容易出现<code>a</code>依赖<code>b</code>，<code>b</code>依赖<code>c</code>，<code>c</code>又依赖<code>a</code>这样的情况。这意味着，模块加载机制必须考虑“循环加载”的情况。 </p>
<p>对于 JavaScript 语言来说，目前最常见的两种模块格式 CommonJS 和 ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样</p>
<h3 id="CommonJS-模块的加载原理"><a href="#CommonJS-模块的加载原理" class="headerlink" title="CommonJS 模块的加载原理"></a>CommonJS 模块的加载原理</h3><p>介绍 ES6 如何处理“循环加载”之前，先介绍目前最流行的 CommonJS 模块格式的加载原理。 </p>
<p>CommonJS 的一个模块，就是一个脚本文件。<code>require</code>命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。</p>
<pre><code>    &#123;
        id: &#39;...&#39;,
        exports: &#123;&#125;,
        loaded: true,
    &#125;
</code></pre>
<p>上面代码就是 Node 内部加载模块后生成的一个对象。该对象的<code>id</code>属性是模块名，<code>exports</code>属性是模块输出的各个接口，<code>loaded</code>属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。 </p>
<p>以后需要用到这个模块的时候，就会到<code>exports</code>属性上面取值。即使再次执行<code>require</code>命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存</p>
<h3 id="CommonJS-模块的循环加载"><a href="#CommonJS-模块的循环加载" class="headerlink" title="CommonJS 模块的循环加载"></a>CommonJS 模块的循环加载</h3><p>CommonJS 模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。 </p>
<p>让我们来看，Node <a target="_blank" rel="noopener" href="https://nodejs.org/api/modules.html#modules_cycles">官方文档</a> 里面的例子。脚本文件a.js代码如下</p>
<pre><code>    exports.done = false
    var b = require(&#39;./b.js&#39;)
    console.log(&#39;在 a.js 之中,b.done = %j&#39;, b.done)
    exports.done = true
    console.log(&#39;a.js 执行完毕&#39;)
</code></pre>
<p>上面代码之中，<code>a.js</code>脚本先输出一个<code>done</code>变量，然后加载另一个脚本文件<code>b.js</code>。注意，此时<code>a.js</code>代码就停在这里，等待<code>b.js</code>执行完毕，再往下执行。</p>
<p>再看<code>b.js</code>的代码</p>
<pre><code>    exports.done = false
    var a = require(&#39;./a.js&#39;)
    console.log(&#39;在 b.js 之中，a.done = %j&#39;, a.done)
    exports.done = true
    console.log(&#39;b.js 执行完毕&#39;)
</code></pre>
<p>上面代码之中，<code>b.js</code>执行到第二行，就会去加载<code>a.js</code>，这时，就发生了“循环加载”。系统会去<code>a.js</code>模块对应对象的<code>exports</code>属性取值，可是因为<code>a.js</code>还没有执行完，从<code>exports</code>属性只能取回已经执行的部分，而不是最后的值。</p>
<p><code>a.js</code>已经执行的部分，只有一行。</p>
<pre><code>    exports.done = false
</code></pre>
<p>因此，对于<code>b.js</code>来说，它从<code>a.js</code>只输入一个变量<code>done</code>，值为<code>false</code>。 </p>
<p>然后，<code>b.js</code>接着往下执行，等到全部执行完毕，再把执行权交还给<code>a.js</code>。于是，<code>a.js</code>接着往下执行，直到执行完毕。我们写一个脚本<code>main.js</code>，验证这个过程。</p>
<pre><code>    var a = require(&#39;./a.js&#39;)
    var b = require(&#39;./b.js&#39;)
    console.log(&#39;在 main.js 之中, a.done=%j, b.done=%j&#39;, a.done, b.done)
</code></pre>
<p>执行<code>main.js</code>，运行结果如下</p>
<pre><code>    $ node main.js
    
    在 b.js 之中，a.done = false
    b.js 执行完毕
    在 a.js 之中，b.done = true
    a.js 执行完毕
    在 main.js 之中, a.done=true, b.done=true
</code></pre>
<p>上面的代码证明了两件事。一是，在<code>b.js</code>之中，<code>a.js</code>没有执行完毕，只执行了第一行。二是，<code>main.js</code>执行到第二行时，不会再次执行<code>b.js</code>，而是输出缓存的<code>b.js</code>的执行结果，即它的第四行。</p>
<pre><code>    exports.done = true
</code></pre>
<p>总之，CommonJS 输入的是被输出值的拷贝，不是引用。 </p>
<p>另外，由于 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心</p>
<pre><code>    var a = require(&#39;a&#39;) // 安全的写法
    var foo = require(&#39;a&#39;).foo // 危险的写法

    exports.good = function (arg) &#123;
        return a.foo(&#39;good&#39;, arg) // 使用的是 a.foo 的最新值
    &#125;

    exports.bad = function (arg) &#123;
        return foo(&#39;bad&#39;, arg) // 使用的是一个部分加载时的值
    &#125;
</code></pre>
<p>上面代码中，如果发生循环加载，<code>require(&#39;a&#39;).foo</code>的值很可能后面会被改写，改用<code>require(&#39;a&#39;)</code>会更保险一点</p>
<h3 id="ES6-模块的循环加载"><a href="#ES6-模块的循环加载" class="headerlink" title="ES6 模块的循环加载"></a>ES6 模块的循环加载</h3><p>ES6 处理“循环加载”与 CommonJS 有本质的不同。ES6 模块是动态引用，如果使用import从一个模块加载变量(即<code>import foo from &#39;foo&#39;</code>)，那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。 </p>
<p>请看下面这个例子。</p>
<pre><code>    // a.mjs
    import &#123; bar &#125; from &#39;./b&#39;
    console.log(&#39;a.mjs&#39;)
    console.log(bar)
    export let foo = &#39;foo&#39;

    // b.mjs
    import &#123; foo &#125; from &#39;./a&#39;
    console.log(&#39;b.mjs&#39;)
    console.log(foo)
    export let bar = &#39;bar&#39;
</code></pre>
<p>上面代码中，<code>a.mjs</code>加载<code>b.mjs</code>，<code>b.mjs</code>又加载<code>a.mjs</code>，构成循环加载。执行<code>a.mjs</code>，结果如下。</p>
<pre><code>    $ node --experimental-modules a.mjs
    b.mjs
    ReferenceError: foo is not defined
</code></pre>
<p>上面代码中，执行<code>a.mjs</code>以后会报错，<code>foo</code>变量未定义，这是为什么？ </p>
<p>让我们一行行来看，ES6 循环加载是怎么处理的。首先，执行<code>a.mjs</code>以后，引擎发现它加载了<code>b.mjs</code>，因此会优先执行<code>b.mjs</code>，然后再执行<code>a.mjs</code>。接着，执行<code>b.mjs</code>的时候，已知它从<code>a.mjs</code>输入了<code>foo</code>接口，这时不会去执行<code>a.mjs</code>，而是认为这个接口已经存在了，继续往下执行。执行到第三行<code>console.log(foo)</code>的时候，才发现这个接口根本没定义，因此报错。 </p>
<p>解决这个问题的方法，就是让<code>b.mjs</code>运行的时候，<code>foo</code>已经有定义了。这可以通过将<code>foo</code>写成函数来解决。</p>
<pre><code>    // a.mjs
    import &#123; bar &#125; from &#39;./b&#39;
    console.log(&#39;a.mjs&#39;)
    console.log(bar())
    function foo() &#123;
        return &#39;foo&#39;
    &#125;
    export &#123; foo &#125;

    // b.mjs
    import &#123; foo &#125; from &#39;./a&#39;
    console.log(&#39;b.mjs&#39;)
    console.log(foo())
    function bar() &#123;
        return &#39;bar&#39;
    &#125;
    export &#123; bar &#125;
</code></pre>
<p>这时再执行<code>a.mjs</code>就可以得到预期结果</p>
<pre><code>    $ node --experimental-modules a.mjs
    b.mjs
    foo
    a.mjs
    bar
</code></pre>
<p>这是因为函数具有提升作用，在执行<code>import &#123;bar&#125; from &#39;./b&#39;</code>时，函数<code>foo</code>就已经有定义了，所以<code>b.mjs</code>加载的时候不会报错。这也意味着，如果把函数<code>foo</code>改写成函数表达式，也会报错</p>
<pre><code>    // a.mjs
    import &#123; bar &#125; from &#39;./b&#39;
    console.log(&#39;a.mjs&#39;)
    console.log(bar())
    const foo = () =&gt; &#39;foo&#39;
    export &#123; foo &#125;
</code></pre>
<p>上面代码的第四行，改成了函数表达式，就不具有提升作用，执行就会报错。</p>
<p>我们再来看 ES6 模块加载器SystemJS给出的一个例子</p>
<pre><code>    // even.js
    import &#123; odd &#125; from &#39;./odd&#39;
    export var counter = 0
    export function even(n) &#123;
        counter++
        return n === 0 || odd(n - 1)
    &#125;

    // odd.js
    import &#123; even &#125; from &#39;./even&#39;
    export function odd(n) &#123;
        return n !== 0 &amp;&amp; even(n - 1)
    &#125;
</code></pre>
<p>上面代码中，<code>even.js</code>里面的函数<code>even</code>有一个参数<code>n</code>，只要不等于 0，就会减去 1，传入加载的<code>odd()</code>。<code>odd.js</code>也会做类似操作。</p>
<p>运行上面这段代码，结果如下</p>
<pre><code>    $ babel-node
    &gt; import * as m from &#39;./even.js&#39;;
    &gt; m.even(10);
    true
    &gt; m.counter
    6
    &gt; m.even(20)
    true
    &gt; m.counter
    17
</code></pre>
<p>上面代码中，参数<code>n</code>从 10 变为 0 的过程中，<code>even()</code>一共会执行 6 次，所以变量<code>counter</code>等于 6。第二次调用<code>even()</code>时，参数<code>n</code>从 20 变为 0，<code>even()</code>一共会执行 11 次，加上前面的 6 次，所以变量<code>counter</code>等于 17。 </p>
<p>这个例子要是改写成 CommonJS，就根本无法执行，会报错</p>
<pre><code>    // even.js
    var odd = require(&#39;./odd&#39;)
    var counter = 0
    exports.counter = counter
    exports.even = function (n) &#123;
        counter++
        return n == 0 || odd(n - 1)
    &#125;

    // odd.js
    var even = require(&#39;./even&#39;).even
    module.exports = function (n) &#123;
        return n != 0 &amp;&amp; even(n - 1)
    &#125;
</code></pre>
<p>上面代码中，<code>even.js</code>加载<code>odd.js</code>，而<code>odd.js</code>又去加载<code>even.js</code>，形成“循环加载”。这时，执行引擎就会输出<code>even.js</code>已经执行的部分(不存在任何结果)，所以在<code>odd.js</code>之中，变量<code>even</code>等于<code>undefined</code>，等到后面调用<code>even(n - 1)</code>就会报错</p>
<pre><code>    $ node
    &gt; var m = require(&#39;./even&#39;);
    &gt; m.even(10)
    TypeError: even is not a function
</code></pre>
<h2 id="ES6-模块的转码"><a href="#ES6-模块的转码" class="headerlink" title="ES6 模块的转码"></a>ES6 模块的转码</h2><p>浏览器目前还不支持 ES6 模块，为了现在就能使用，可以将转为 ES5 的写法。除了 Babel 可以用来转码之外，还有以下两个方法，也可以用来转码</p>
<h3 id="ES6-module-transpiler"><a href="#ES6-module-transpiler" class="headerlink" title="ES6 module transpiler"></a>ES6 module transpiler</h3><p><a target="_blank" rel="noopener" href="https://github.com/esnext/es6-module-transpiler">ES6 module transpiler</a>是 square 公司开源的一个转码器，可以将 ES6 模块转为 CommonJS 模块或 AMD 模块的写法，从而在浏览器中使用</p>
<p>首先，安装这个转码器。 </p>
<pre><code>    npm install -g es6-module-transpiler
</code></pre>
<p>然后，使用<code>compile-modules convert</code>命令，将 ES6 模块文件转码。</p>
<pre><code>    compile-modules convert file1.js file2.js
</code></pre>
<p><code>-o</code>参数可以指定转码后的文件名。 </p>
<pre><code>    compile-modules convert -o out.js file1.js
</code></pre>
<h3 id="SystemJS"><a href="#SystemJS" class="headerlink" title="SystemJS"></a>SystemJS</h3><p>另一种解决方法是使用 <a target="_blank" rel="noopener" href="https://github.com/systemjs/systemjs">SystemJS</a> 。它是一个垫片库(polyfill)，可以在浏览器内加载 ES6 模块、AMD 模块和 CommonJS 模块，将其转为 ES5 格式。它在后台调用的是 Google 的 Traceur 转码器。 </p>
<p>使用时，先在网页内载入system.js文件</p>
<pre><code>    &lt;script src=&quot;system.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>然后，使用<code>System.import</code>方法加载模块文件。 </p>
<pre><code>    &lt;script&gt;
        System.import(&quot;./app.js&quot;)
    &lt;/script&gt;
</code></pre>
<p>上面代码中的<code>./app</code>，指的是当前目录下的 <code>app.js</code> 文件。它可以是 ES6 模块文件，<code>System.import</code>会自动将其转码。 </p>
<p>需要注意的是，<code>System.import</code>使用异步加载，返回一个 Promise 对象，可以针对这个对象编程。</p>
<p>下面是一个模块文件。</p>
<pre><code>    // app/es6-file.js:

    export class q &#123;
        constructor() &#123;
            this.es6 = &#39;hello&#39;
        &#125;
    &#125;
</code></pre>
<p>然后，在网页内加载这个模块文件</p>
<pre><code>    &lt;script&gt;
        System.import(&#39;app/es6-file&#39;).then(function (m) &#123;
            console.log(new m.q().es6) // hello
        &#125;)
    &lt;/script&gt;
</code></pre>
<p>上面代码中，<code>System.import方</code>法返回的是一个 Promise 对象，所以可以用<code>then</code>方法指定回调函数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/21/ES6/%E6%A8%A1%E5%9D%97%E5%8C%96%20module/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fangck">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/21/ES6/%E6%A8%A1%E5%9D%97%E5%8C%96%20module/" class="post-title-link" itemprop="url">Module 模块化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-21 15:32:08" itemprop="dateCreated datePublished" datetime="2022-07-21T15:32:08+08:00">2022-07-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-23 23:49:05" itemprop="dateModified" datetime="2022-07-23T23:49:05+08:00">2022-07-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ES6/" itemprop="url" rel="index"><span itemprop="name">ES6</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="模块化-module"><a href="#模块化-module" class="headerlink" title="模块化 module"></a>模块化 module</h1><h2 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h2><p>历史上，JavaScript 一直没有模块(<code>module</code>)体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的<code>require</code>、Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p>
<p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/07/21/ES6/%E6%A8%A1%E5%9D%97%E5%8C%96%20module/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/19/ES6/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fangck">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/19/ES6/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95/" class="post-title-link" itemprop="url">对象的扩展</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-19 15:57:08" itemprop="dateCreated datePublished" datetime="2022-07-19T15:57:08+08:00">2022-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-22 17:07:13" itemprop="dateModified" datetime="2022-07-22T17:07:13+08:00">2022-07-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ES6/" itemprop="url" rel="index"><span itemprop="name">ES6</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h1><h2 id="属性的简介表示"><a href="#属性的简介表示" class="headerlink" title="属性的简介表示"></a>属性的简介表示</h2><p>ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p>
<pre><code>    const foo = &quot;bar&quot;
    const baz = &#123; foo &#125;
    baz // &#123;foo: &quot;bar&quot;&#125;

    // 等同于
    // const baz = &#123; foo: foo &#125;
</code></pre>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/07/19/ES6/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/25/ES6/Class%E7%9A%84%E7%BB%A7%E6%89%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fangck">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/25/ES6/Class%E7%9A%84%E7%BB%A7%E6%89%BF/" class="post-title-link" itemprop="url">Class的基本用法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-25 15:22:19" itemprop="dateCreated datePublished" datetime="2022-06-25T15:22:19+08:00">2022-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-18 17:33:50" itemprop="dateModified" datetime="2022-07-18T17:33:50+08:00">2022-07-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ES6/" itemprop="url" rel="index"><span itemprop="name">ES6</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Class的基本用法"><a href="#Class的基本用法" class="headerlink" title="Class的基本用法"></a>Class的基本用法</h1><p>Class 可以通过<code>extends</code>关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/06/25/ES6/Class%E7%9A%84%E7%BB%A7%E6%89%BF/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/24/ES6/Class%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fangck">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/24/ES6/Class%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/" class="post-title-link" itemprop="url">Class的基本用法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-24 15:11:40" itemprop="dateCreated datePublished" datetime="2022-06-24T15:11:40+08:00">2022-06-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-19 21:45:35" itemprop="dateModified" datetime="2022-07-19T21:45:35+08:00">2022-07-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ES6/" itemprop="url" rel="index"><span itemprop="name">ES6</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Class的基本用法"><a href="#Class的基本用法" class="headerlink" title="Class的基本用法"></a>Class的基本用法</h1><p>ES6 提供了更接近传统语言的写法，引入了 Class(类)这个概念，作为对象的模板。通过class关键字，可以定义类。<br>基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/06/24/ES6/Class%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/18/ES6/set%E4%B8%8Emap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fangck">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/18/ES6/set%E4%B8%8Emap/" class="post-title-link" itemprop="url">set 与 map</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-18 09:11:59" itemprop="dateCreated datePublished" datetime="2021-12-18T09:11:59+08:00">2021-12-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-19 15:22:27" itemprop="dateModified" datetime="2021-12-19T15:22:27+08:00">2021-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ES6/" itemprop="url" rel="index"><span itemprop="name">ES6</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="set-与-map"><a href="#set-与-map" class="headerlink" title="set 与 map"></a>set 与 map</h1><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6 提供了新的数据结构 Set。它类似于数组，<strong>但是成员的值都是唯一的，没有重复的值</strong>。</p>
<p>Set 本身是一个构造函数，用来生成 Set 数据结构。</p>
<h4 id="set-结构的声明"><a href="#set-结构的声明" class="headerlink" title="set 结构的声明"></a>set 结构的声明</h4><pre><code>    let s = new Set()
    let s2 = new Set([1, 2, 3, 4])
</code></pre>
<h4 id="set-的初始化"><a href="#set-的初始化" class="headerlink" title="set 的初始化"></a>set 的初始化</h4><p>Set 函数可以接受一个数组(或者具有 iterable 接口的其他数据结构)作为参数，用来初始化</p>
<pre><code>    let arr = [1, 2, 3, 4]
    let s = new Set(arr)

    let s2 = new Set()
    arr.forEach((x) =&gt; s.add(x))

    let s3 = new Set(document.querySelectorAll(&quot;div&quot;))
</code></pre>
<h4 id="set-转换为数组"><a href="#set-转换为数组" class="headerlink" title="set 转换为数组"></a>set 转换为数组</h4><p>使用<code>...</code>扩展运算符或<code>Array.from</code>方法</p>
<pre><code>    let s = new Set([1, 2, 3, 4])
    let arr = [...s]
    let arr2 = Array.from(set)
</code></pre>
<p>因此有两种数组去重的方法</p>
<pre><code>    let s = new Set([1, 1, 2, 3, 4, 2])
    let arr = [...s]
    let arr2 = Array.from(s)
</code></pre>
<h4 id="注"><a href="#注" class="headerlink" title="注"></a>注</h4><p>向 Set 加入值的时候，不会发生类型转换，所以5和”5”是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符(===)，主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。 </p>
<pre><code>    let set = new Set()
    let a = NaN
    let b = NaN
    set.add(a)
    set.add(b)
    // Set &#123;NaN&#125;
</code></pre>
<p>上面代码向 Set 实例添加了两个NaN，但是只能加入一个。这表明，在 Set 内部，两个NaN是相等.另外，两个对象总是不相等的</p>
<pre><code>    let set = new Set();
    
    set.add(&#123;&#125;);
    set.size; // 1
    
    set.add(&#123;&#125;);
    set.size; // 2
</code></pre>
<h3 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法"></a>Set 实例的属性和方法</h3><p>属性：</p>
<ul>
<li><code>Set.prototype.constructor</code>: 构造函数，默认就是Set函数。</li>
<li><code>Set.prototype.size</code>: 返回Set实例的成员总数。</li>
</ul>
<p>方法：<br>Set 实例的方法分为两大类: 操作方法(用于操作数据)和遍历方法(用于遍历成员)。下面先介绍四个操作方法</p>
<ul>
<li><p><code>add(value)</code>: 添加某个值，返回 Set 结构本身。 </p>
</li>
<li><p><code>delete(value)</code>: 删除某个值，返回一个布尔值，表示删除是否成功。 </p>
</li>
<li><p><code>has(value)</code>: 返回一个布尔值，表示该值是否为Set的成员。 </p>
</li>
<li><p><code>clear()</code>: 清除所有成员，没有返回值。</p>
<pre><code>  s.add(1).add(2).add(2)
  s.size // 2
  
  s.has(1) // true
  s.has(2) // true
  s.has(3) // false
  
  s.delete(2)
  s.has(2) // false
</code></pre>
</li>
</ul>
<h3 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h3><p>Set 结构的实例有四个遍历方法，可以用于遍历成员。</p>
<ul>
<li><code>keys()</code>: 返回键名的遍历器</li>
<li><code>values()</code>: 返回键值的遍历器</li>
<li><code>entries()</code>: 返回键值对的遍历器</li>
<li><code>forEach()</code>: 使用回调函数遍历每个成员</li>
</ul>
<p>需要特别指出的是，<strong>Set的遍历顺序就是插入顺序</strong>。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。</p>
<p>1.<code>keys()</code>，<code>values()</code>，<code>entries()</code><br>以上三个方法的返回值都是遍历器对象。由于 Set 结构没有键名，只有键值(或者说键名和键值是同一个值)，所以<code>keys()</code>方法和<code>values()</code>方法的行为完全一致</p>
<pre><code>    let set = new Set([&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]);
    
    for (let item of set.keys()) &#123;
      console.log(item);
    &#125;
    // red
    // green
    // blue
    
    for (let item of set.values()) &#123;
      console.log(item);
    &#125;
    // red
    // green
    // blue
    
    for (let item of set.entries()) &#123;
      console.log(item);
    &#125;
    // [&quot;red&quot;, &quot;red&quot;]
    // [&quot;green&quot;, &quot;green&quot;]
    // [&quot;blue&quot;, &quot;blue&quot;]
</code></pre>
<p>上面代码中，<code>entries()</code>方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</p>
<p>Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法</p>
<pre><code>    Set.prototype[Symbol.iterator] === Set.prototype.values  // true
</code></pre>
<p>2.forEach()<br>Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值</p>
<pre><code>    set = new Set([&quot;red&quot;, &quot;bule&quot;, &quot;black&quot;])
    set.forEach((value, key) =&gt; console.log(key + &quot; : &quot; + value))
    // red : red
    // bule : bule
    // black : black
</code></pre>
<p>上面代码说明，forEach方法的参数就是一个处理函数。该函数的参数与数组的forEach一致，依次为键值、键名、集合本身(上例省略了该参数)。这里需要注意，Set 结构的键名就是键值(两者是同一个值)，因此第一个参数与第二个参数的值永远都是一样的。<br>另外，forEach方法还可以有第二个参数，表示绑定处理函数内部的this对象</p>
<p>3.遍历的应用</p>
<p>实现并集(Union)、交集(Intersect)和差集(Difference)</p>
<pre><code>    let s = new Set([1, 2, 3])
    let s2 = new Set([2, 3, 4])
    
    // 并集
    let union = new Set([...s, ...s2])
    //交集
    let intersect = new Set([...s].filter(num =&gt; s2.has(num)))
    //差集
    let difference = new Set([...s].filter(num =&gt; !s2.has(num)))
</code></pre>
<p>如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用<code>Array.from()</code>方法。 </p>
<pre><code>    // 方法一
    let set = new Set([1, 2, 3]);
    set = new Set([...set].map(val =&gt; val * 2));
    // set的值是2, 4, 6
    
    // 方法二
    let set = new Set([1, 2, 3]);
    set = new Set(Array.from(set, val =&gt; val * 2));
    // set的值是2, 4, 6
</code></pre>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>JavaScript 的对象(Object)，本质上是键值对的集合(Hash 结构)，但是传统上只能用字符串当作键。这给它的使用带来了很大的限制</p>
<p>ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值(包括对象)都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果您需要“键值对”的数据结构，Map 比 Object 更合适。</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="map-创建"><a href="#map-创建" class="headerlink" title="map 创建"></a>map 创建</h4><p>作为构造函数，Map 也可以接受一个数组作为参数。该<strong>数组的成员是一个个表示键值对的数组</strong></p>
<pre><code>    let m = new Map([
        [&quot;name&quot;, &quot;tom&quot;],
        [&quot;age&quot;, 18]
    ])
    m.size //2
</code></pre>
<p>上面代码在新建 Map 实例时，就指定了两个键<code>name</code>和<code>age</code>，相当于下面代码<br>        let item = [<br>            [“name”, “tom”],<br>            [“age”, 18]<br>        ]</p>
<pre><code>    let m = new Map()
    item.forEach(([key, value]) =&gt; m.set(key, value))
</code></pre>
<p>不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构都可以当作Map构造函数的参数。这就是说，Set和Map都可以用来生成新的 Map。</p>
<pre><code>    let s = new Set([
        [&quot;name&quot;, &quot;tom&quot;],
        [&quot;age&quot;, 18]
    ])
    
    let m = new Map(s)
    let m2 = new Map(m)
    console.log(m == m2) //false
</code></pre>
<p>同样的值的两个实例，在 Map 结构中被视为两个键<br>        const map = new Map()</p>
<pre><code>    const k1 = [&quot;a&quot;]
    const k2 = [&quot;a&quot;]
    
    map.set(k1, 111).set(k2, 222)
    
    map.get(k1) // 111
    map.get(k2) // 222
</code></pre>
<p>变量k1和k2的值是一样的，但是它们在 Map 结构中被视为两个键<br>由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞(clash)的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名</p>
<h3 id="map-的属性和操作方法"><a href="#map-的属性和操作方法" class="headerlink" title="map 的属性和操作方法"></a>map 的属性和操作方法</h3><ol>
<li><p>size 属性<br>size属性返回map的成员总数</p>
<pre><code> let map = new Map()
 map.set(&quot;foo&quot;, 1)
 map.set(&quot;bar&quot;, 2)
 // map.size == 3
</code></pre>
</li>
<li><p><code>set(key, value)</code><br>set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键</p>
<pre><code> let m = new Map()
 let a = &quot;abc&quot;
 m.set(a, 3) //键是变量
 m.set(&quot;edition&quot;, 6) // 键是字符串
 m.set(262, &quot;standard&quot;) // 键是数值
 m.set(undefined, &quot;nah&quot;) // 键是 undefined
</code></pre>
<p><code>set()</code>方法返回的是当前的Map对象，因此可以采用链式写法。</p>
<pre><code> let a = &quot;abc&quot;
 const m = new Map().set(a, 3).set(&quot;edition&quot;, 6).set(262, &quot;standard&quot;)
</code></pre>
</li>
<li><p>get(key)<br><code>get()</code> 方法读取key所对应的键值</p>
<pre><code> let map = new Map([
     [&quot;foo&quot;, 1]
 ])
 map.get(&quot;foo&quot;) // 1
</code></pre>
</li>
<li><p>has(key)<br><code>has()</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中</p>
<pre><code> let map = new Map([
     [&quot;foo&quot;, 1]
 ])
 map.has(&quot;foo&quot;) // true
 map.has(&quot;bar&quot;) //false
</code></pre>
</li>
<li><p>delete(key)<br><code>delete()</code>方法删除某个键，返回true。如果删除失败，返回false</p>
<pre><code> let map = new Map([
     [&quot;foo&quot;, 1]
 ])
 map.delete(&quot;foo&quot;)
 console.log(map.has(&quot;foo&quot;)) // false
</code></pre>
</li>
<li><p>clear()<br><code>clear()</code>方法清除所有成员，没有返回值</p>
<pre><code> let map = new Map([
     [&quot;foo&quot;, 1],
     [&quot;bar&quot;, 2]
 ])
 map.clear()
 map.size //0
</code></pre>
</li>
</ol>
<h3 id="map-的遍历操作"><a href="#map-的遍历操作" class="headerlink" title="map 的遍历操作"></a>map 的遍历操作</h3><p>Map 结构原生提供三个遍历器生成函数和一个遍历方法。 </p>
<ul>
<li><p><code>keys()</code>: 返回键名的遍历器。 </p>
</li>
<li><p><code>values()</code>: 返回键值的遍历器。 </p>
</li>
<li><p><code>entries()</code>: 返回所有成员的遍历器。 </p>
</li>
<li><p><code>forEach()</code>: 遍历 Map 的所有成员</p>
<pre><code>  let map = new Map([
      [&quot;foo&quot;, 1],
      [&quot;bar&quot;, 2]
  ])

  for (const key of map.keys()) &#123;
      console.log(key)
  &#125;
  // foo , bar 
  
  for (const value of map.values()) &#123;
      console.log(value)
  &#125;
  // 1 , 2

  for (const item of map.entries()) &#123;
      console.log(item)
  &#125;
  // [&quot;foo&quot;, 1] , [&quot;bar&quot;, 2]

  for (const [key, value] of map.entries()) &#123;
    console.log(key, value)
  &#125;
  // [&quot;foo&quot;, 1] , [&quot;bar&quot;, 2]

  // 等同于使用map.entries()
  for (const [key, value] of map) &#123;
    console.log(key, value);
  &#125;
  // [&quot;foo&quot;, 1] , [&quot;bar&quot;, 2]
</code></pre>
</li>
</ul>
<p>上面代码最后的那个例子，表示 Map 结构的默认遍历器接口(<code>Symbol.iterator</code>属性)，就是<code>entries()</code>方法</p>
<pre><code>    map[Symbol.iterator] === map.entries;
    // true
</code></pre>
<p>结合数组的map方法、filter方法，可以实现 Map 的遍历和过滤(Map 本身没有map和filter方法)。</p>
<pre><code>    const map0 = new Map().set(1, &quot;a&quot;).set(2, &quot;b&quot;).set(3, &quot;c&quot;);
    
    const map1 = new Map([...map0].filter(([k, v]) =&gt; k &lt; 3));
    // 产生 Map 结构 &#123;1 =&gt; &#39;a&#39;, 2 =&gt; &#39;b&#39;&#125;
    
    const map2 = new Map([...map0].map(([k, v]) =&gt; [k * 2, &quot;_&quot; + v]));
    // 产生 Map 结构 &#123;2 =&gt; &#39;_a&#39;, 4 =&gt; &#39;_b&#39;, 6 =&gt; &#39;_c&#39;&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Fangck"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Fangck</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019-12 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fangck</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">全站共84.1k字</span>
</div>
        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
